/* Obfuscated Designer JavaScript - Thu Aug 21 08:16:21 PM EDT 2025 */

/**
 * Vanilla Three.js Designer Implementation
 * 
 * Loading State Management:
 * - Tracks loading of model, design/template, and fonts
 * - Shows loading spinner until ALL components are fully loaded
 * - Prevents premature hiding of loading overlay
 */

// Debug logging utility - only logs in development environment
function debugLog(...args) {
  const data = window.phpData || window.designerData;
  if (data && data.environment === 'development') {
    console.log(...args);
  }
}

function debugWarn(...args) {
  const data = window.phpData || window.designerData;
  if (data && data.environment === 'development') {
    console.warn(...args);
  }
}

function debugError(...args) {
  const data = window.phpData || window.designerData;
  if (data && data.environment === 'development') {
    console.error(...args);
  }
}

// Global variables
let scene, camera, renderer, controls, raycaster;
let currentLayer = null;
let currentDecal = null;
let layers = {};
let loaded = false;
let designName = "Untitled Design";
let currentDesignId = null;
let pmremGenerator;

// Shared canvas for text rendering
let textCanvas = null;
let textCanvasCtx = null;

// Font loading status
let fontsLoaded = false;

// Comprehensive loading state tracking
let loadingState = {
  model: false,
  design: false,
  fonts: false,
  isFullyLoaded: function() {
    return this.model && this.design && this.fonts;
  },
  checkAndHideLoader: function() {
    if (this.isFullyLoaded()) {
      $("#loading-overlay").hide();
      loaded = true;
      debugLog("✅ All components loaded - hiding loader");
    }
  }
};

// Create a placeholder text texture using system fonts
function createPlaceholderTextTexture(text, font, color) {
  initTextCanvas();
  
  const canvasSize = 2048;
  textCanvas.width = canvasSize;
  textCanvas.height = canvasSize;
  
  textCanvasCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
  
  // Use system font as placeholder
  const placeholderFont = 'Arial, sans-serif';
  const fontSize = 200; // Large placeholder size
  
  textCanvasCtx.font = `${fontSize}px ${placeholderFont}`;
  textCanvasCtx.textAlign = 'center';
  textCanvasCtx.textBaseline = 'middle';
  textCanvasCtx.fillStyle = color;
  
  const centerX = textCanvas.width / 2;
  const centerY = textCanvas.height / 2;
  
  textCanvasCtx.fillText(text, centerX, centerY);
  
  const texture = new THREE.CanvasTexture(textCanvas);
  texture.flipY = false;
  texture.needsUpdate = true;
  
  return texture;
}

// Update text decal when fonts are ready
async function updateTextDecalWhenFontsReady(decal) {
  try {
    // Wait for fonts to load if not already loaded
    if (!fontsLoaded) {
      await loadAllFonts();
    }
    
    // Create proper texture with loaded font
    const properTexture = await renderTextToTexture(
      decal.text,
      decal.font,
      decal.color,
      decal.letterSpacing,
      decal.borderWidth,
      decal.borderColor
    );
    
    // Update the decal
    decal.texture = properTexture;
    decal.isLoadingFont = false;
    
    // Re-render the layer that contains this decal
    const decalLayer = Object.values(layers).find(layer => 
      layer.decals.some(d => d.id === decal.id)
    );
    if (decalLayer) {
      const previousCurrentLayer = currentLayer;
      currentLayer = decalLayer;
      renderLayer();
      currentLayer = previousCurrentLayer;
    }
    
    // Update font selector if this decal is being edited
    if (currentDecal && currentDecal.id === decal.id) {
      updateFontSelectorLoadingState();
    }
    
    debugLog(`✅ Font loaded for decal: ${decal.name}`);
  } catch (error) {
    debugError(`❌ Failed to load font for decal: ${decal.name}`, error);
    decal.isLoadingFont = false;
  }
}

// Test if a font is actually working in canvas
function testFontInCanvas(font, testText = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789") {
  const testCanvas = document.createElement('canvas');
  const testCtx = testCanvas.getContext('2d');
  
  // Test multiple fallback fonts to get a good baseline
  const fallbacks = ['serif', 'sans-serif', 'monospace'];
  const fallbackWidths = fallbacks.map(fallback => {
    testCtx.font = `72px ${fallback}`;
    return testCtx.measureText(testText).width;
  });
  
  // Measure with target font
  testCtx.font = `72px "${font}", sans-serif`;
  const targetWidth = testCtx.measureText(testText).width;
  
  // Check if the target width is different from all fallbacks
  const isUnique = fallbackWidths.every(fallbackWidth => 
    Math.abs(targetWidth - fallbackWidth) > 2
  );
  
  // Also check if font is in document.fonts
  const fontInDocument = Array.from(document.fonts).some(f => 
    f.family.toLowerCase().includes(font.toLowerCase()) || 
    f.family === `"${font}"` ||
    f.family === font
  );
  
  const fontWorking = isUnique || fontInDocument;
  
  debugLog(`🧪 Font test "${font}": width=${targetWidth}px, unique=${isUnique}, inDocument=${fontInDocument}, working=${fontWorking}`);
  
  return fontWorking;
}

// Cart variables
let sizeQuantities = {}; // Object to store quantities for each size

// Three.js loaders - initialize after DOM is ready
let gltfLoader, textureLoader, rgbeLoader;

// Cache for font loading status
const fontCache = new Map();

// Load all Google Fonts and cache them
async function loadAllFonts() {
  if (!window.phpData || !window.phpData.fonts) {
    // No fonts to load, mark as ready
    fontsLoaded = true;
    loadingState.fonts = true;
    loadingState.checkAndHideLoader();
    return;
  }
  
  debugLog("🔤 Preloading ALL Google Fonts...");
  
  try {
    // Wait for document fonts to be ready
    debugLog("⏳ Waiting for document.fonts.ready...");
    await document.fonts.ready;
    debugLog("✅ document.fonts.ready completed");
    
    // Additional wait for Google Fonts to settle
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Aggressively preload each font with multiple sizes and weights
    debugLog("🚀 Aggressively preloading fonts...");
    const preloadPromises = [];
    
    for (const font of window.phpData.fonts) {
      // Load multiple sizes and weights to cache them
      const sizes = [16, 24, 48, 72, 96, 144, 200];
      const weights = [400, 700];
      
      for (const size of sizes) {
        for (const weight of weights) {
          preloadPromises.push(
            document.fonts.load(`${weight} ${size}px "${font}"`).catch(() => {})
          );
        }
      }
    }
    
    await Promise.all(preloadPromises);
    debugLog("✅ Font preloading completed");
    
    // Test each font and cache results
    const workingFonts = [];
    const failedFonts = [];
    
    debugLog("🧪 Testing and caching fonts...");
    for (const font of window.phpData.fonts) {
      const isWorking = testFontInCanvas(font);
      fontCache.set(font, isWorking);
      
      if (isWorking) {
        workingFonts.push(font);
        debugLog(`  ✅ ${font} - WORKING & CACHED`);
      } else {
        failedFonts.push(font);
        debugLog(`  ❌ ${font} - FAILED`);
      }
    }
    
    debugLog(`📊 Font Summary: ${workingFonts.length}/${window.phpData.fonts.length} working & cached`);
    if (workingFonts.length > 0) {
      debugLog("✅ Working fonts:", workingFonts);
    }
    if (failedFonts.length > 0) {
      debugWarn("❌ Failed fonts:", failedFonts);
    }
    
    fontsLoaded = true;
    loadingState.fonts = true;
    loadingState.checkAndHideLoader();
  } catch (error) {
    debugError("💥 Font loading failed:", error);
    fontsLoaded = true; // Continue anyway
    loadingState.fonts = true;
    loadingState.checkAndHideLoader();
  }
}

// Initialize the designer
$(document).ready(function () {
  debugLog("Designer initializing...");

  // Load fonts first
  loadAllFonts();

  // Wait for all Three.js scripts to load
  function checkThreeJSReady() {
    if (
      typeof THREE !== "undefined" &&
      THREE.GLTFLoader &&
      THREE.OrbitControls &&
      THREE.RGBELoader
    ) {
      debugLog("Three.js ready, initializing...");

      // Initialize loaders
      gltfLoader = new THREE.GLTFLoader();
      textureLoader = new THREE.TextureLoader();
      rgbeLoader = new THREE.RGBELoader();

      initThreeJS();
      
      // Check if product data exists before loading
      if (window.phpData && window.phpData.product) {
        loadProduct(window.phpData.product);
      } else {
        debugError("No product data available. Designer may not function properly.");
        // Continue loading without product data
      }
      
      initUI();
      
      // Set default name based on mode
      if (window.phpData && (window.phpData.createTemplate || window.phpData.templateEditId)) {
        designName = "Untitled Template";
        // Update the design name display and input after UI is initialized
        setTimeout(() => {
          updateDesignNameDisplay();
          const designNameInput = document.getElementById('design-name-input');
          if (designNameInput) {
            designNameInput.value = designName;
          }
        }, 100);
      }
    } else {
      debugLog("Waiting for Three.js...");
      setTimeout(checkThreeJSReady, 100);
    }
  }

  checkThreeJSReady();
});

/**
 * Load saved design data
 */
function loadSavedDesign(designData) {
  debugLog("Loading saved design:", designData);

  // Set design name
  if (designData.name) {
    designName = designData.name;
    updateDesignNameDisplay();
  }

  // Set current design ID for updates
  currentDesignId = designData.id;

  // Load design data
  if (designData.design_data && designData.design_data.layers) {
    const savedLayers = designData.design_data.layers;
    
    // Track pending texture loads
    const pendingTextureLoads = [];
    
    // Apply saved layer data
    Object.entries(savedLayers).forEach(([layerName, savedLayer]) => {
      const layer = layers[layerName];
      if (layer) {
        // Apply color
        if (savedLayer.color) {
          const color = new THREE.Color(savedLayer.color);
          layer.mesh.material.color.copy(color);
        }

        // Apply material
        if (savedLayer.material) {
          setLayerMaterial(layer, savedLayer.material);
        }

        // Apply decals
        if (savedLayer.decals && Array.isArray(savedLayer.decals)) {
          savedLayer.decals.forEach(decalData => {
            // Recreate decal based on saved data
            const decal = createDecalFromSavedData(decalData, pendingTextureLoads);
            if (decal) {
              layer.decals.push(decal);
              debugLog('Added decal to layer:', decal.name, 'type:', decal.type, 'has texture:', !!decal.texture);
            }
          });
        }
      }
    });

    // Update UI
    populateLayerTabs();
    updateMaterialOptions();
    updateDesignNameDisplay();
    updateDecalsList();
    
    // Function to render all layers after textures are loaded
    const renderAllLayers = () => {
      debugLog('All textures loaded, rendering all layers');
      
      // Set current layer to first layer and render
      if (Object.keys(layers).length > 0) {
        const firstLayerName = Object.keys(layers)[0];
        setCurrentLayer(firstLayerName);
        
        // Render each layer to ensure all changes are visible
        Object.keys(layers).forEach(layerName => {
          renderSpecificLayer(layerName);
        });
        
        // Final render with the first layer as current
        currentLayer = layers[firstLayerName];
        renderLayer();
      }
      
      // Force a final render to ensure everything is visible
      if (renderer && scene && camera) {
        renderer.render(scene, camera);
      }
      
      // Mark design as fully loaded and hide loader
      loadingState.design = true;
      loadingState.checkAndHideLoader();
    };
    
    // Wait for all textures to load
    if (pendingTextureLoads.length > 0) {
      debugLog(`Waiting for ${pendingTextureLoads.length} textures to load...`);
      Promise.all(pendingTextureLoads).then(() => {
        renderAllLayers();
      }).catch(error => {
        debugError('Some textures failed to load:', error);
        // Render anyway to show what loaded successfully
        renderAllLayers();
      });
    } else {
      // No textures to wait for, render immediately
      renderAllLayers();
    }
  } else {
    // No design data, mark as loaded immediately
    loadingState.design = true;
    loadingState.checkAndHideLoader();
  }
}

/**
 * Create decal from saved data
 */
function createDecalFromSavedData(decalData, pendingTextureLoads = []) {
  try {
    debugLog('Creating decal from saved data:', decalData);
    
    const decal = {
      id: decalData.id || generateId(),
      name: decalData.name || 'Untitled',
      type: decalData.type || 'text',
      position: decalData.position || { x: 0.5, y: 0.5 },
      size: decalData.size || { x: 0.3, y: 0.3 },
      rotation: decalData.rotation || 0,
      opacity: decalData.opacity || 1,
      flipX: decalData.flipX || false,
      flipY: decalData.flipY || false,
      aspectLocked: decalData.aspectLocked !== false
    };

    // Recreate texture based on type
    if (decalData.type === 'text') {
      // Recreate text texture
      const textData = decalData.textData || {};
      debugLog('Recreating text texture:', textData);
      
      // Store text properties directly on the decal object for consistency
      decal.text = textData.text || 'Sample Text';
      decal.font = textData.font || 'Roboto';
      decal.color = textData.color || '#000000';
      decal.letterSpacing = textData.letterSpacing || 0;
      decal.borderWidth = textData.borderWidth || 0;
      decal.borderColor = textData.borderColor || '#000000';
      
      // Create text texture asynchronously and wait for fonts
      updateTextDecalWhenFontsReady(decal);
      
      // Store textData for consistency
      decal.textData = textData;
    } else if (decalData.type === 'image') {
      // Recreate image texture
      if (decalData.imageUrl) {
        debugLog('Recreating image texture:', decalData.imageUrl);
        
        // Handle proxy URL for R2 storage images
        let proxyUrl = decalData.imageUrl;
        if (decalData.imageUrl.includes("filess.model2design.app/")) {
          const imagePath = decalData.imageUrl.replace("https://filess.model2design.app/", "");
          proxyUrl = `/api/image-proxy.php?path=${encodeURIComponent(imagePath)}`;
          debugLog('Using proxy URL:', proxyUrl);
        }
        
        // Create a promise for this texture load
        const textureLoadPromise = new Promise((resolve, reject) => {
          decal.texture = textureLoader.load(proxyUrl, 
            // onLoad callback
            function(texture) {
              debugLog('Image texture loaded successfully:', proxyUrl);
              resolve(texture);
            },
            // onProgress callback
            undefined,
            // onError callback
            function(error) {
              debugError('Error loading image texture:', proxyUrl, error);
              reject(error);
            }
          );
        });
        
        // Add to pending loads if array provided
        if (pendingTextureLoads) {
          pendingTextureLoads.push(textureLoadPromise);
        }
        
        decal.texture.flipY = false;
        decal.imageUrl = decalData.imageUrl;
      } else {
        debugWarn('Image decal saved without imageUrl:', decalData);
      }
    } else if (decalData.type === 'fade') {
      // Recreate fade texture with enhanced parameters
      const fadeData = decalData.fadeData || {
        baseColor: '#000000',
        blendColor: '#ffffff',
        fadeStart: 0.4,
        mixRatio: 0.5,
        direction: 'Vertical'
      };
      debugLog('Recreating fade texture:', fadeData);
      decal.texture = createFadeTexture(fadeData);
      decal.fadeData = fadeData;
    }

    if (decal.texture) {
      debugLog('Decal texture created successfully:', decal.texture);
    } else {
      debugWarn('No texture created for decal:', decalData);
    }

    return decal;
  } catch (error) {
    debugError('Error creating decal from saved data:', error);
    return null;
  }
}

/**
 * Set layer material
 */
function setLayerMaterial(layer, materialName) {
  if (layer.meshSettings && layer.meshSettings.materials) {
    const materialData = layer.meshSettings.materials[materialName];
    if (materialData) {
      applyMaterial(layer.mesh, materialData);
      layer.material = materialName;
    }
  }
}

/**
 * Initialize Three.js scene
 */
function initThreeJS() {
  // Create scene
  scene = new THREE.Scene();
  scene.background = null; // Keep transparent for CSS backgrounds

  // Create camera
  camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
  camera.position.set(0, 0, 5);

  // Create renderer with enhanced antialiasing
  renderer = new THREE.WebGLRenderer({
    antialias: true,
    preserveDrawingBuffer: true,
    powerPreference: "high-performance",
    alpha: true,
  });
  renderer.setSize(800, 600);
  
  // Set transparent background
  renderer.setClearColor(0x000000, 0); // Black with 0 alpha (transparent)
  renderer.setClearAlpha(0); // Ensure alpha is 0
  
  // Force canvas to be transparent
  renderer.domElement.style.background = 'transparent';
  renderer.domElement.style.backgroundColor = 'transparent';

  // Enhanced antialiasing and quality settings
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2x for performance

  // Shadow mapping disabled since we're using environment lighting only
  renderer.shadowMap.enabled = false;
  renderer.outputEncoding = THREE.LinearEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1;

  // Add to DOM
  const container = document.getElementById("canvas-container");
  container.appendChild(renderer.domElement);

  // Create PMREM generator for environment maps
  pmremGenerator = new THREE.PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();

  // Create controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.enablePan = false;

  // Create raycaster for mesh selection
  raycaster = new THREE.Raycaster();

  // Add right-click event listener for mesh selection
  renderer.domElement.addEventListener('contextmenu', onCanvasRightClick);

  // No scene lighting - using only environment map from neutral.hdr for illumination

  // Load environment map
  loadEnvironmentMap();

  // Handle window resize
  window.addEventListener("resize", onWindowResize);

  // Call resize once to set initial size
  onWindowResize();

  // Start render loop
  animate();

  debugLog("Three.js initialized");
}

/**
 * Animation loop
 */
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

/**
 * Handle window resize
 */
function onWindowResize() {
  const container = document.getElementById("canvas-container");
  const width = container.clientWidth;
  const height = container.clientHeight;

  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Maintain pixel ratio

  // Re-fit camera if model is loaded
  if (loaded && scene.children.length > 2) {
    // More than just lights
    const model = scene.children.find(
      (child) => child.type === "Group" || child.type === "Object3D"
    );
    if (model) {
      fitCameraToModel(model);
    }
  }
}

/**
 * Handle right-click on canvas for mesh selection
 */
function onCanvasRightClick(event) {
  event.preventDefault(); // Prevent context menu

  // Only proceed if we have a loaded model and layers
  if (!loaded || Object.keys(layers).length === 0) {
    return;
  }

  // Calculate mouse position in normalized device coordinates (-1 to +1)
  const rect = renderer.domElement.getBoundingClientRect();
  const mouse = new THREE.Vector2();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  // Set up raycaster
  raycaster.setFromCamera(mouse, camera);

  // Find all meshes in the scene to intersect with
  const meshes = [];
  scene.traverse((child) => {
    if (child.isMesh) {
      meshes.push(child);
    }
  });

  // Calculate intersections
  const intersects = raycaster.intersectObjects(meshes);

  if (intersects.length > 0) {
    // Get the first (closest) intersected object
    const intersectedMesh = intersects[0].object;
    const meshName = intersectedMesh.name;

    // Check if this mesh corresponds to a layer and can be selected
    if (layers[meshName] && layers[meshName].meshSettings && layers[meshName].meshSettings.canSelect) {
      debugLog('Right-clicked mesh:', meshName, 'switching to layer');
      setCurrentLayer(meshName);
    } else {
      debugLog('Right-clicked mesh:', meshName, 'but it cannot be selected');
    }
  }
}

/**
 * Load environment map for better lighting and reflections
 */
function loadEnvironmentMap() {
  rgbeLoader.load(
    "/static/neutral.hdr",
    function (texture) {
      texture.mapping = THREE.EquirectangularReflectionMapping;

      // Generate environment map
      const envMap = pmremGenerator.fromEquirectangular(texture).texture;

      // Set as scene environment for reflections
      scene.environment = envMap;

      // Optional: also set as background
      // scene.background = envMap;

      texture.dispose();
      pmremGenerator.dispose();
    },
    function (progress) {
      debugLog("Loading environment map...", progress);
    },
    function (error) {
      debugError("Error loading environment map:", error);
      // Continue without environment map
    }
  );
}

/**
 * Load a product
 */
function loadProduct(product) {
  debugLog("Loading product:", product);

  if (!product) {
    debugError("No product provided");
    return;
  }

  $("#product-name").text(`(${product.name})`);

  // Clear existing scene objects
  clearScene();

  // Load the 3D model - fix the path
  const modelPath = product.modelLink.startsWith("/models/")
    ? product.modelLink.replace("/models/", "/static/models/")
    : product.modelLink;

  gltfLoader.load(
    modelPath,
    function (gltf) {
      debugLog("Model loaded:", gltf);

      const model = gltf.scene;
      scene.add(model);

      // Initialize layers from the model
      initializeLayers(model);

      // Mark model as loaded
      loadingState.model = true;

      // Load saved design if provided
      if (window.phpData?.designData) {
        loadSavedDesign(window.phpData.designData);
      } else {
        // No design to load, mark as ready
        loadingState.design = true;
      }
      
      // Check if everything is loaded
      loadingState.checkAndHideLoader();

      // Update UI
      populateLayerTabs();
      updateColorControls();
      updateMaterialOptions();

      // Set initial layer from product data
      if (window.phpData.product && window.phpData.product.initialLayer) {
        const initialLayer = window.phpData.product.initialLayer;
        debugLog("Setting initial layer to:", initialLayer);
        
        // Find the layer tab and click it
        const layerTab = $(`.layer-tab[data-layer="${initialLayer}"]`);
        if (layerTab.length > 0) {
          layerTab.click();
        } else {
          debugLog("Initial layer not found:", initialLayer);
        }
      }

      // Auto-fit camera
      fitCameraToModel(model);
    },
    function (progress) {
      debugLog("Loading progress:", progress);
    },
    function (error) {
      debugError("Loading error:", error);
      $("#loading-overlay").hide();
    }
  );
}

/**
 * Clear the scene
 */
function clearScene() {
  // Properly dispose of all objects
  const objectsToRemove = [];

  scene.traverse((child) => {
    if (child.isMesh || child.isLight) {
      objectsToRemove.push(child);
    }
  });

  objectsToRemove.forEach((obj) => {
    scene.remove(obj);

    // Dispose geometry
    if (obj.geometry) {
      obj.geometry.dispose();
    }

    // Dispose material
    if (obj.material) {
      if (obj.material.map) obj.material.map.dispose();
      if (obj.material.bumpMap) obj.material.bumpMap.dispose();
      if (obj.material.normalMap) obj.material.normalMap.dispose();
      obj.material.dispose();
    }
  });

  layers = {};
  currentLayer = null;
  currentDecal = null;
}

/**
 * Initialize layers from the 3D model
 */
function initializeLayers(model) {
  layers = {};

  model.traverse((child) => {
    if (child.isMesh && child.material && !child.name.includes("polySurface")) {
      debugLog("Found mesh:", child.name);

      // Clone material to avoid sharing
      child.material = child.material.clone();
      child.material.metalness = 0;
      child.material.roughness = 1;

      // Ensure material doesn't have color space conversion issues
      if (child.material.map) {
        child.material.map.encoding = THREE.sRGBEncoding;
      }

      // Get mesh settings from product data
      const meshSettings =
        window.phpData?.product?.meshSettings &&
        window.phpData.product.meshSettings[child.name]
          ? window.phpData.product.meshSettings[child.name]
          : { canSelect: true, canAddImages: true, canChangeColor: true };

      // Set initial color
      if (meshSettings.initialColor) {
        child.material.color.setHex(parseInt(meshSettings.initialColor, 16));
      }

      // Create layer object
      layers[child.name] = {
        name: child.name,
        mesh: child,
        decals: [],
        material: window.phpData?.product?.initialBumpmap || "none",
        meshSettings: meshSettings,
        minX: meshSettings.minX || 0,
        maxX: meshSettings.maxX || 1,
        minY: meshSettings.minY || 0,
        maxY: meshSettings.maxY || 1,
        roughness: 1,
        metalness: 0,
      };
    }
  });

  // Set initial layer - find first selectable layer
  let initialLayer = window.phpData.product.initialLayer;

  // If initial layer is not selectable, find first selectable layer
  if (
    !initialLayer ||
    !layers[initialLayer] ||
    !layers[initialLayer].meshSettings.canSelect
  ) {
    initialLayer = Object.keys(layers).find(
      (layerName) =>
        layers[layerName].meshSettings &&
        layers[layerName].meshSettings.canSelect
    );
  }

  if (initialLayer && layers[initialLayer]) {
    setCurrentLayer(initialLayer);
  }

  // Apply initial bumpmap to all layers if specified
  if (
    window.phpData.product.initialBumpmap &&
    window.phpData.product.initialBumpmap !== "none"
  ) {
    const initialBumpmap = window.phpData.product.initialBumpmap;
    const bumpmap = window.phpData.bumpmaps[initialBumpmap];

    if (bumpmap) {
      // Apply initial material to all layers that can change bumpmap
      Object.values(layers).forEach((layer) => {
        if (layer.meshSettings && layer.meshSettings.canChangeBumpmap) {
          applyBumpmapToLayer(layer, initialBumpmap, bumpmap);
        }
      });
    }
  }

  debugLog("Layers initialized:", Object.keys(layers));
}

/**
 * Fit camera to model
 */
function fitCameraToModel(model) {
  const box = new THREE.Box3().setFromObject(model);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());

  // Get the max dimension considering aspect ratio
  const container = document.getElementById("canvas-container");
  const aspect = container.clientWidth / container.clientHeight;

  // Calculate the dimension that matters based on aspect ratio
  const horizontalFOV =
    2 * Math.atan(Math.tan((camera.fov * Math.PI) / 360) * aspect);
  const verticalFOV = (camera.fov * Math.PI) / 180;

  // Determine limiting dimension
  const horizontalDistance = size.x / (2 * Math.tan(horizontalFOV / 2));
  const verticalDistance = size.y / (2 * Math.tan(verticalFOV / 2));
  const depthDistance = size.z * 0.5;

  // Use the largest required distance with a small margin
  const distance =
    Math.max(horizontalDistance, verticalDistance, depthDistance) * 1.5;

  // Position camera at the front
  camera.position.set(center.x, center.y, center.z + distance);

  // Set controls target to center
  controls.target.copy(center);
  controls.update();

  // Also adjust controls zoom limits based on model size
  controls.minDistance = distance * 0.5;
  controls.maxDistance = distance * 3;
}

/**
 * Set current layer
 */
function setCurrentLayer(layerName) {
  if (!layers[layerName]) return;

  // Check if layer is selectable
  if (
    !layers[layerName].meshSettings ||
    !layers[layerName].meshSettings.canSelect
  ) {
    debugWarn("Layer", layerName, "is not selectable");
    return;
  }

  // Exit decal edit mode if currently in it
  if (window.inDecalEditMode) {
    exitDecalEditMode();
  }

  currentLayer = layers[layerName];
  currentDecal = null;

  debugLog("Current layer set to:", layerName);

  // Update layer tabs
  updateLayerTabsActive(layerName);

  // Update all UI sections
  updateColorControls();
  updateMaterialOptions();
  updateDecalsList();
}

/**
 * Populate layer tabs
 */
function populateLayerTabs() {
  const container = $("#layer-tabs");
  container.empty();

  // Get the order of layers from product meshSettings
  const productMeshSettings = window.phpData.product.meshSettings || {};
  const meshOrder = Object.keys(productMeshSettings);
  
  // Create sorted array of layers based on meshSettings order
  const sortedLayers = [];
  
  // First, add layers in the order they appear in meshSettings
  meshOrder.forEach(meshName => {
    if (layers[meshName] && layers[meshName].meshSettings && layers[meshName].meshSettings.canSelect) {
      sortedLayers.push(layers[meshName]);
    }
  });
  
  // Then add any remaining selectable layers that weren't in meshSettings (fallback)
  Object.values(layers).forEach((layer) => {
    if (layer.meshSettings && layer.meshSettings.canSelect && !sortedLayers.includes(layer)) {
      sortedLayers.push(layer);
    }
  });

  // Create tabs in sorted order
  sortedLayers.forEach((layer) => {
    // Replace underscores with spaces for display
    const displayName = layer.name.replace(/_/g, " ");

    const tab = $(`
      <button class="layer-tab" data-layer="${layer.name}">
        ${displayName}
      </button>
    `);

    // Add click handler
    tab.on("click", function () {
      setCurrentLayer(layer.name);
    });

    container.append(tab);
  });

  // Set initial active tab
  if (currentLayer) {
    updateLayerTabsActive(currentLayer.name);
  }
}

/**
 * Update active state of layer tabs
 */
function updateLayerTabsActive(layerName) {
  $(".layer-tab").removeClass("active");
  $(`.layer-tab[data-layer="${layerName}"]`).addClass("active");
}

/**
 * Update color controls for current layer
 */
function updateColorControls() {
  const colorSection = $(".design-section").first(); // Color section

  if (
    !currentLayer ||
    !currentLayer.meshSettings ||
    !currentLayer.meshSettings.canChangeColor
  ) {
    // Hide color section if layer can't change color
    colorSection.hide();
    return;
  }

  // Show color section and update values
  colorSection.show();
  const currentColor = currentLayer.mesh.material.color.getHexString();
  $("#color-picker").val("#" + currentColor);
  $("#hex-input").val(currentColor.toUpperCase());

  // Initialize copy color popover
  initCopyColorPopover();
}

/**
 * Set current layer color from color picker
 */
function setCurrentLayerColor(color) {
  if (!currentLayer) return;

  // Check if current layer can change color
  if (!currentLayer.meshSettings || !currentLayer.meshSettings.canChangeColor) {
    debugWarn("Current layer cannot change color");
    return;
  }

  // Set color for current layer
  currentLayer.mesh.material.color.setHex(parseInt(color.replace("#", ""), 16));

  // Check for linked meshes and update them too
  const meshSettings = currentLayer.meshSettings;
  if (meshSettings.linkedColors) {
    meshSettings.linkedColors.forEach((linkedMeshName) => {
      const linkedLayer = layers[linkedMeshName];
      if (linkedLayer) {
        linkedLayer.mesh.material.color.setHex(
          parseInt(color.replace("#", ""), 16)
        );
      }
    });
  }

  // Update the hex input to match (without #)
  $("#hex-input").val(color.replace("#", "").toUpperCase());

  // Reinitialize popover to update color previews
  initCopyColorPopover();
}

/**
 * Set current layer color from hex input
 */
function setCurrentLayerColorFromHex(hex) {
  if (!currentLayer || !hex) return;

  // Check if current layer can change color
  if (!currentLayer.meshSettings || !currentLayer.meshSettings.canChangeColor) {
    debugWarn("Current layer cannot change color");
    return;
  }

  // Remove any # if present
  hex = hex.replace("#", "");

  // Pad with zeros if less than 6 characters while typing
  if (hex.length < 6) {
    hex = hex.padEnd(6, "0");
  }

  // Ensure only first 6 characters
  hex = hex.substring(0, 6);

  // Add # prefix
  hex = "#" + hex;

  // Validate hex color (allow partial hex during typing)
  if (!/^#[0-9A-F]{0,6}$/i.test(hex)) {
    return;
  }

  // Set color for current layer
  const hexColorValue = parseInt(hex.replace("#", ""), 16);
  currentLayer.mesh.material.color.setHex(hexColorValue);

  // Ensure material updates properly
  currentLayer.mesh.material.needsUpdate = true;

  // Check for linked meshes and update them too
  const meshSettings = currentLayer.meshSettings;
  if (meshSettings.linkedColors) {
    meshSettings.linkedColors.forEach((linkedMeshName) => {
      const linkedLayer = layers[linkedMeshName];
      if (linkedLayer) {
        const linkedHexValue = parseInt(hex.replace("#", ""), 16);
        linkedLayer.mesh.material.color.setHex(linkedHexValue);
        linkedLayer.mesh.material.needsUpdate = true;
      }
    });
  }

  // Update the color picker to match
  $("#color-picker").val(hex);

  // Don't update hex input if this was called from hex input to avoid cursor jumping

  // Reinitialize popover to update color previews
  initCopyColorPopover();
}

/**
 * Initialize copy color popover
 */
function initCopyColorPopover() {
  const copyBtn = $("#copy-color-btn");

  // Destroy existing popover if any
  const existingPopover = bootstrap.Popover.getInstance(copyBtn[0]);
  if (existingPopover) {
    existingPopover.dispose();
  }

  // Get layers that can change color
  const colorableLayers = [];
  Object.entries(layers).forEach(([layerName, layer]) => {
    if (
      layer.meshSettings &&
      layer.meshSettings.canChangeColor &&
      layerName !== currentLayer.name
    ) {
      colorableLayers.push({
        name: layerName,
        displayName: layer.meshSettings.displayName || layerName,
        color: "#" + layer.mesh.material.color.getHexString(),
      });
    }
  });

  if (colorableLayers.length === 0) {
    copyBtn.prop("disabled", true);
    return;
  }

  copyBtn.prop("disabled", false);

  // Build popover content
  let popoverContent =
    '<div class="copy-color-popover"><ul class="copy-color-list">';

  // Add "All Layers" option if there are multiple layers
  if (colorableLayers.length > 1) {
    popoverContent += `
      <li class="copy-color-item all-layers" onclick="copyColorToAllLayers()">
        <div class="layer-color-preview" style="background: linear-gradient(45deg, #ddd 25%, transparent 25%), linear-gradient(-45deg, #ddd 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ddd 75%), linear-gradient(-45deg, transparent 75%, #ddd 75%); background-size: 8px 8px; background-position: 0 0, 0 4px, 4px -4px, -4px 0px;"></div>
        <span>All Layers</span>
      </li>
    `;
  }

  // Add individual layers
  colorableLayers.forEach((layer) => {
    // Replace underscores with spaces in display name
    const formattedName = layer.displayName.replace(/_/g, " ");
    popoverContent += `
      <li class="copy-color-item" onclick="copyColorToLayer('${layer.name}')">
        <div class="layer-color-preview" style="background-color: ${layer.color}"></div>
        <span>${formattedName}</span>
      </li>
    `;
  });
  popoverContent += "</ul></div>";

  // Initialize popover
  new bootstrap.Popover(copyBtn[0], {
    content: popoverContent,
    trigger: "click",
    placement: "bottom",
    html: true,
    sanitize: false,
  });
}

/**
 * Copy current layer color to another layer
 */
function copyColorToLayer(targetLayerName) {
  if (!currentLayer || !targetLayerName) return;

  const targetLayer = layers[targetLayerName];
  if (!targetLayer) return;

  // Get current color
  const currentColor = currentLayer.mesh.material.color.getHex();

  // Apply to target layer
  targetLayer.mesh.material.color.setHex(currentColor);

  // Check for linked meshes
  if (targetLayer.meshSettings && targetLayer.meshSettings.linkedColors) {
    targetLayer.meshSettings.linkedColors.forEach((linkedMeshName) => {
      const linkedLayer = layers[linkedMeshName];
      if (linkedLayer) {
        linkedLayer.mesh.material.color.setHex(currentColor);
      }
    });
  }

  // Close popover
  const copyBtn = $("#copy-color-btn");
  const popover = bootstrap.Popover.getInstance(copyBtn[0]);
  if (popover) {
    popover.hide();
  }

  debugLog(`Copied color to ${targetLayerName}`);

  // Reinitialize popover with updated colors
  setTimeout(() => {
    initCopyColorPopover();
  }, 100);
}

/**
 * Copy current layer color to all colorable layers
 */
function copyColorToAllLayers() {
  if (!currentLayer) return;

  // Get current color
  const currentColor = currentLayer.mesh.material.color.getHex();

  // Apply to all layers that can change color
  Object.entries(layers).forEach(([layerName, layer]) => {
    if (
      layer.meshSettings &&
      layer.meshSettings.canChangeColor &&
      layerName !== currentLayer.name
    ) {
      // Apply to layer
      layer.mesh.material.color.setHex(currentColor);

      // Check for linked meshes
      if (layer.meshSettings.linkedColors) {
        layer.meshSettings.linkedColors.forEach((linkedMeshName) => {
          const linkedLayer = layers[linkedMeshName];
          if (linkedLayer) {
            linkedLayer.mesh.material.color.setHex(currentColor);
          }
        });
      }
    }
  });

  // Close popover
  const copyBtn = $("#copy-color-btn");
  const popover = bootstrap.Popover.getInstance(copyBtn[0]);
  if (popover) {
    popover.hide();
  }

  debugLog("Copied color to all layers");

  // Reinitialize popover with updated colors
  setTimeout(() => {
    initCopyColorPopover();
  }, 100);
}

/**
 * Update material options
 */
function updateMaterialOptions() {
  const materialSection = $(".design-section").eq(1); // Material section
  const container = $("#material-options");
  
  // Clear any existing timeout to prevent race conditions
  if (window.materialUpdateTimeout) {
    clearTimeout(window.materialUpdateTimeout);
  }
  
  container.empty();

  if (
    !currentLayer ||
    !currentLayer.meshSettings ||
    !currentLayer.meshSettings.canChangeBumpmap
  ) {
    // Hide material section if layer can't change material
    materialSection.hide();
    return;
  }

  // Show material section
  materialSection.show();

  // Get supported bumpmaps for this product
  const supportedBumpmaps = window.phpData.product.supportedBumpmaps || [];

  // Only show materials that are supported by this product
  Object.entries(window.phpData.bumpmaps).forEach(([key, bumpmap]) => {
    // Skip if this material is not supported by the product
    if (supportedBumpmaps.length > 0 && !supportedBumpmaps.includes(key)) {
      return;
    }

    const isSelected = currentLayer && currentLayer.material === key;
    const tooltipText = bumpmap.description || bumpmap.name;

    const item = $(`
      <div class="material-item-wrapper" data-material="${key}" title="${tooltipText}">
        <div class="material-item ${isSelected ? "selected" : ""}">
          <img src="${bumpmap.thumbnail}" alt="${bumpmap.name}">
        </div>
        <div class="material-name">${bumpmap.name}</div>
      </div>
    `);

    container.append(item);
  });
  
  // Use event delegation to handle clicks even after DOM rebuilding
  container.off('click.material').on('click.material', '.material-item-wrapper', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const materialKey = $(this).data('material');
    if (materialKey) {
      // Update selected state immediately
      container.find(".material-item").removeClass("selected");
      $(this).find(".material-item").addClass("selected");
      setBumpmap(materialKey);
    }
  });
}

/**
 * Apply optimal texture settings for quality and performance
 */
function applyTextureSettings(texture, isBumpMap = false) {
  texture.generateMipmaps = true;
  texture.anisotropy = Math.min(16, renderer.capabilities.getMaxAnisotropy());
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

  // Set flipY to false for all textures (decals and bumpmaps)
  texture.flipY = false;

  // Better filtering for bump maps to reduce zoom artifacts
  if (isBumpMap) {
    texture.minFilter = THREE.LinearMipMapLinearFilter;
    texture.magFilter = THREE.LinearFilter;
  } else {
    texture.minFilter = THREE.LinearMipMapLinearFilter;
    texture.magFilter = THREE.LinearFilter;
  }

  // No encoding set - matches R3F with colorManagement={false}
}

/**
 * Apply bumpmap to a specific layer
 */
function applyBumpmapToLayer(layer, materialKey, bumpmap) {
  // Handle "none" material (remove texture)
  if (materialKey === "none" || !bumpmap.link) {
    layer.mesh.material.bumpMap = null;
    layer.mesh.material.bumpScale = 1;
    layer.mesh.material.roughness = 1;
    layer.mesh.material.metalness = 0;
    layer.mesh.material.needsUpdate = true;

    layer.material = materialKey;
    layer.roughness = 1;
    layer.metalness = 0;

    debugLog("Material texture removed for layer:", layer.name);
    return;
  }

  // Load and apply texture
  textureLoader.load(
    bumpmap.link,
    function (texture) {
      // Apply optimal texture settings for bump maps
      applyTextureSettings(texture, true);

      // Apply texture and material properties (following R3F approach)
      layer.mesh.material.bumpMap = texture;
      // Use scale values directly from data (now that they're corrected)
      layer.mesh.material.bumpScale = bumpmap.scale || 1;
      layer.mesh.material.metalness = bumpmap.metalness || 0;
      layer.mesh.material.roughness = bumpmap.roughness || 1;

      // Set repeat after assigning bumpMap (matching R3F approach)
      const size = bumpmap.size || 1;
      layer.mesh.material.bumpMap.repeat.set(size, size);

      layer.mesh.material.needsUpdate = true;

      debugLog("Bumpmap debug info:", {
        materialKey,
        bumpScale: layer.mesh.material.bumpScale,
        repeat: { x: size, y: size },
        textureSize: {
          width: texture.image?.width,
          height: texture.image?.height,
        },
        encoding: texture.encoding,
        format: texture.format,
        flipY: texture.flipY,
      });

      // Store material properties on layer
      layer.material = materialKey;
      layer.roughness = bumpmap.roughness !== undefined ? bumpmap.roughness : 1;
      layer.metalness = bumpmap.metalness !== undefined ? bumpmap.metalness : 0;

      debugLog("Material applied to layer", layer.name, ":", {
        key: materialKey,
        scale: bumpmap.scale,
        size: size,
        roughness: layer.roughness,
        metalness: layer.metalness,
      });
    },
    undefined,
    function (error) {
      debugError("Error loading bumpmap texture:", bumpmap.link, error);
    }
  );
}

/**
 * Set bumpmap material
 */
function setBumpmap(materialKey) {
  if (!currentLayer) return;

  // Check if current layer can change bumpmap
  if (
    !currentLayer.meshSettings ||
    !currentLayer.meshSettings.canChangeBumpmap
  ) {
    debugWarn("Current layer cannot change material");
    return;
  }

  // Check if this material is supported by the product
  const supportedBumpmaps = window.phpData.product.supportedBumpmaps || [];
  if (
    supportedBumpmaps.length > 0 &&
    !supportedBumpmaps.includes(materialKey)
  ) {
    debugWarn("Material", materialKey, "is not supported by this product");
    return;
  }

  const bumpmap = window.phpData.bumpmaps[materialKey];
  if (!bumpmap) return;

  debugLog("Setting bumpmap:", materialKey);

  // Function to apply material to a layer
  const applyMaterialToLayer = (layer) => {
    applyBumpmapToLayer(layer, materialKey, bumpmap);
  };

  // Apply to current layer
  applyMaterialToLayer(currentLayer);

  // Apply to linked meshes if they exist
  const meshSettings = currentLayer.meshSettings;
  if (meshSettings.linkedBumpmaps) {
    meshSettings.linkedBumpmaps.forEach((linkedMeshName) => {
      const linkedLayer = layers[linkedMeshName];
      if (linkedLayer) {
        applyMaterialToLayer(linkedLayer);
      }
    });
  }

  // Don't rebuild the UI - just update the material property
  // updateMaterialOptions() was causing the double-click issue
}

/**
 * Update decals list
 */
function updateDecalsList() {
  const designSection = $(".design-section").eq(2); // Designs section
  const container = $("#decals-list");
  container.empty();

  if (
    !currentLayer ||
    !currentLayer.meshSettings ||
    !currentLayer.meshSettings.canAddImages
  ) {
    // Hide designs section if layer can't add images
    designSection.hide();
    return;
  }

  // Show designs section
  designSection.show();

  if (!currentLayer || currentLayer.decals.length === 0) {
    container.html('<p class="text-muted">No designs</p>');
    return;
  }

  currentLayer.decals.forEach((decal, index) => {
    const isActive = currentDecal && currentDecal.id === decal.id;
    const item = $(`
      <div class="design-element-item ${
        isActive ? "active" : ""
      }" data-decal="${decal.id}" data-index="${index}" draggable="true">
        <div class="design-element-content">
          <div class="design-element-drag-handle">
            <i class="bi bi-grip-vertical" style="cursor: grab;"></i>
          </div>
          <div class="design-element-info">
            <div class="design-element-name">${decal.name}</div>
          </div>
          <div class="design-element-actions">
            <button class="btn btn-xs btn-outline-secondary" onclick="showDecalLayerMenu('${
              decal.id
            }', this)" title="Move/Copy to Layer">
              <i class="bi bi-layers" style="font-size: 12px;"></i>
            </button>
            <button class="btn btn-xs btn-outline-secondary" onclick="duplicateDecal('${
              decal.id
            }')" title="Duplicate">
              <i class="bi bi-files" style="font-size: 12px;"></i>
            </button>
            <button class="btn btn-xs btn-outline-danger" onclick="deleteDecal('${
              decal.id
            }')" title="Delete">
              <i class="bi bi-trash" style="font-size: 12px;"></i>
            </button>
          </div>
        </div>
      </div>
    `);

    // Click handler
    item.on("click", function (e) {
      // Don't select if clicking on buttons or drag handle
      if ($(e.target).closest("button, .design-element-drag-handle").length === 0) {
        setCurrentDecal(decal.id);
      }
    });

    // Drag and drop handlers
    item.on("dragstart", function (e) {
      e.originalEvent.dataTransfer.setData("text/plain", decal.id);
      $(this).addClass("dragging");
    });

    item.on("dragend", function (e) {
      $(this).removeClass("dragging");
      $(".design-element-item").removeClass("drag-over drag-over-top drag-over-bottom");
    });

    item.on("dragover", function (e) {
      e.preventDefault();
      e.originalEvent.dataTransfer.dropEffect = "move";
      
      // Remove drag-over from all items first
      $(".design-element-item").removeClass("drag-over-top drag-over-bottom");
      
      // Get mouse position relative to element
      const rect = this.getBoundingClientRect();
      const midpoint = rect.top + rect.height / 2;
      const mouseY = e.originalEvent.clientY;
      
      // Add appropriate class based on mouse position
      if (mouseY < midpoint) {
        $(this).addClass("drag-over-top");
      } else {
        $(this).addClass("drag-over-bottom");
      }
    });

    item.on("dragenter", function (e) {
      e.preventDefault();
    });

    item.on("dragleave", function (e) {
      // Only remove if we're actually leaving the element (not entering a child)
      const rect = this.getBoundingClientRect();
      const x = e.originalEvent.clientX;
      const y = e.originalEvent.clientY;
      
      if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
        $(this).removeClass("drag-over-top drag-over-bottom");
      }
    });

    item.on("drop", function (e) {
      e.preventDefault();
      const draggedDecalId = e.originalEvent.dataTransfer.getData("text/plain");
      const targetDecalId = decal.id;
      
      if (draggedDecalId !== targetDecalId) {
        // Check if we should insert before or after based on the drop indicator
        const insertBefore = $(this).hasClass("drag-over-top");
        reorderDecals(draggedDecalId, targetDecalId, insertBefore);
      }
      
      $(".design-element-item").removeClass("drag-over drag-over-top drag-over-bottom");
    });

    container.append(item);
  });

  // No longer adding inline decal editor - will use full-screen mode instead
}

/**
 * Reorder decals by moving one decal to another position
 */
function reorderDecals(draggedDecalId, targetDecalId, insertBefore = false) {
  if (!currentLayer || !currentLayer.decals) return;
  
  const draggedIndex = currentLayer.decals.findIndex(d => d.id === draggedDecalId);
  const targetIndex = currentLayer.decals.findIndex(d => d.id === targetDecalId);
  
  if (draggedIndex === -1 || targetIndex === -1) return;
  
  // Remove the dragged decal from its current position
  const draggedDecal = currentLayer.decals.splice(draggedIndex, 1)[0];
  
  // Calculate the new insertion index
  let newIndex = targetIndex;
  
  // If we removed an item before the target, adjust the target index
  if (draggedIndex < targetIndex) {
    newIndex = targetIndex - 1;
  }
  
  // If we want to insert before the target, use the calculated index
  // If we want to insert after, add 1 to the index
  if (!insertBefore) {
    newIndex = newIndex + 1;
  }
  
  // Insert it at the new position
  currentLayer.decals.splice(newIndex, 0, draggedDecal);
  
  // Update the UI and re-render
  updateDecalsList();
  renderLayer();
  
  debugLog(`Moved decal "${draggedDecal.name}" from position ${draggedIndex} to ${newIndex} (${insertBefore ? 'before' : 'after'} target)`);
}

// Old addDecalEditor function removed - replaced with full-screen editor

/**
 * Set current decal
 */
function setCurrentDecal(decalId) {
  if (!currentLayer) return;

  currentDecal = currentLayer.decals.find((d) => d.id === decalId);
  debugLog("Current decal set to:", decalId);

  // Enter full-screen edit mode
  enterDecalEditMode();
}

/**
 * Enter full-screen decal edit mode
 */
function enterDecalEditMode() {
  if (!currentDecal) return;

  const designContent = $(".design-content");

  // Store the original content
  if (!window.originalDesignContent) {
    window.originalDesignContent = designContent.html();
  }

  // Create the full-screen editor
  const editorHTML = `
    <div class="decal-edit-mode">
      <!-- Header -->
      <div class="decal-edit-header">
        <div class="decal-edit-back-row">
          <button class="btn btn-outline-secondary btn-sm" onclick="exitDecalEditMode()">
            <i class="bi bi-arrow-left me-1"></i> Back to Design
          </button>
        </div>
        <div class="decal-edit-main-row">
          <div class="decal-edit-title">
            <h5 class="mb-0">Edit Design</h5>
            <small class="text-muted">${currentDecal.name}</small>
          </div>
          <div class="decal-edit-actions">
            <button class="btn btn-outline-secondary decal-edit-icon-btn" onclick="showDecalLayerMenu('${
              currentDecal.id
            }', this)" title="Move/Copy to Layer">
              <i class="bi bi-layers"></i>
            </button>
            <button class="btn btn-outline-secondary decal-edit-icon-btn" onclick="duplicateDecalAndStayInEdit('${
              currentDecal.id
            }')" title="Duplicate">
              <i class="bi bi-files"></i>
            </button>
            <button class="btn btn-outline-danger decal-edit-icon-btn" onclick="deleteDecal('${
              currentDecal.id
            }'); exitDecalEditMode();" title="Delete">
              <i class="bi bi-trash"></i>
            </button>
          </div>
        </div>
      </div>
      
      <!-- Editor Content -->
      <div class="decal-edit-content">
        <div class="container-fluid">
          <div class="row gx-3">
            ${currentDecal.type === 'text' ? `
            <div class="decal-edit-section">
              <h6 class="decal-edit-section-title">
                <i class="bi bi-fonts me-2"></i>Text Content
              </h6>
              <div class="decal-control-group">
                <div class="control-row">
                  <label class="control-label">Text</label>
                  <div class="control-input-group">
                    <input type="text" class="form-control" id="text-content-input" 
                           value="${currentDecal.text || 'Sample Text'}" 
                           oninput="updateTextProperty('text', this.value)">
                  </div>
                </div>
              </div>
            </div>
            
            <div class="decal-edit-section">
              <h6 class="decal-edit-section-title">
                <i class="bi bi-palette me-2"></i>Text Style
              </h6>
              <div class="decal-control-group">
                <div class="control-row">
                  <label class="control-label">Font</label>
                  <div class="control-input-group">
                    <div class="position-relative">
                      <button class="btn btn-outline-secondary dropdown-toggle w-100 text-start" type="button" id="text-font-dropdown">
                        <span id="text-font-display">Loading fonts...</span>
                      </button>
                      <ul class="dropdown-menu" id="text-font-menu" style="display: none; position: fixed; z-index: 9999; max-height: 300px; overflow-y: auto; min-width: 200px;">
                        <!-- Options populated by JavaScript -->
                      </ul>
                    </div>
                  </div>
                </div>
                <div class="control-row">
                  <label class="control-label">Text Color</label>
                  <div class="control-input-group">
                    <input type="color" class="form-control form-control-color" id="text-color-input" 
                           value="${currentDecal.color || '#000000'}" 
                           oninput="updateTextProperty('color', this.value)">
                    <span class="value-display" id="text-color-value">${currentDecal.color || '#000000'}</span>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="decal-edit-section">
              <h6 class="decal-edit-section-title">
                <i class="bi bi-type me-2"></i>Text Effects
              </h6>
              <div class="decal-control-group">
                <div class="control-row">
                  <label class="control-label">Letter Spacing</label>
                  <div class="control-input-group">
                    <input type="range" class="form-range" id="text-letter-spacing-range" 
                           min="-20" max="50" value="${currentDecal.letterSpacing || 0}" 
                           oninput="document.getElementById('text-letter-spacing-value').textContent = this.value + 'px'; updateTextProperty('letterSpacing', parseInt(this.value))">
                    <span class="value-display" id="text-letter-spacing-value">${currentDecal.letterSpacing || 0}px</span>
                  </div>
                </div>
                <div class="control-row">
                  <label class="control-label">Border Width</label>
                  <div class="control-input-group">
                    <input type="range" class="form-range" id="text-border-width-range" 
                           min="0" max="20" value="${currentDecal.borderWidth || 0}" 
                           oninput="document.getElementById('text-border-width-value').textContent = this.value + 'px'; updateTextProperty('borderWidth', parseInt(this.value))">
                    <span class="value-display" id="text-border-width-value">${currentDecal.borderWidth || 0}px</span>
                  </div>
                </div>
                <div class="control-row">
                  <label class="control-label">Border Color</label>
                  <div class="control-input-group">
                    <input type="color" class="form-control form-control-color" id="text-border-color-input" 
                           value="${currentDecal.borderColor || '#000000'}" 
                           oninput="updateTextProperty('borderColor', this.value)">
                    <span class="value-display" id="text-border-color-value">${currentDecal.borderColor || '#000000'}</span>
                  </div>
                </div>
              </div>
            </div>
            ` : ''}
            
            ${currentDecal.type === 'fade' ? `
            <div class="decal-edit-section">
              <h6 class="decal-edit-section-title">
                <i class="bi bi-circle-half me-2"></i>Fade Settings
              </h6>
              <div class="decal-control-group">
                <div class="control-row">
                  <label class="control-label">Base Color</label>
                  <div class="control-input-group">
                    <input type="color" class="form-control form-control-color" id="fade-base-color-input" 
                           value="${currentDecal.fadeData?.baseColor || '#000000'}" 
                           oninput="updateFadeProperty('baseColor', this.value)">
                    <span class="value-display" id="fade-base-color-value">${currentDecal.fadeData?.baseColor || '#000000'}</span>
                  </div>
                </div>
                <div class="control-row">
                  <label class="control-label">Blend Color</label>
                  <div class="control-input-group">
                    <input type="color" class="form-control form-control-color" id="fade-blend-color-input" 
                           value="${currentDecal.fadeData?.blendColor || '#ffffff'}" 
                           oninput="updateFadeProperty('blendColor', this.value)">
                    <span class="value-display" id="fade-blend-color-value">${currentDecal.fadeData?.blendColor || '#ffffff'}</span>
                  </div>
                </div>
                <div class="control-row">
                  <label class="control-label">Fade Start</label>
                  <div class="control-input-group">
                    <input type="range" class="form-range" min="0" max="1" step="0.01" id="fade-start-input"
                           value="${currentDecal.fadeData?.fadeStart || 0.4}" 
                           oninput="updateFadeProperty('fadeStart', parseFloat(this.value))">
                    <span class="value-display" id="fade-start-value">${Math.round((currentDecal.fadeData?.fadeStart || 0.4) * 100)}%</span>
                  </div>
                </div>
                <div class="control-row">
                  <label class="control-label">Mix Ratio</label>
                  <div class="control-input-group">
                    <input type="range" class="form-range" min="0" max="1" step="0.01" id="fade-mix-ratio-input"
                           value="${currentDecal.fadeData?.mixRatio || 0.5}" 
                           oninput="updateFadeProperty('mixRatio', parseFloat(this.value))">
                    <span class="value-display" id="fade-mix-ratio-value">${Math.round((currentDecal.fadeData?.mixRatio || 0.5) * 100)}%</span>
                  </div>
                </div>
                <div class="control-row">
                  <label class="control-label">Direction</label>
                  <div class="control-input-group">
                    <select class="form-select" id="fade-direction-input" 
                            onchange="updateFadeProperty('direction', this.value)">
                      <option value="Vertical" ${(currentDecal.fadeData?.direction || 'Vertical') === 'Vertical' ? 'selected' : ''}>Vertical</option>
                      <option value="Horizontal" ${(currentDecal.fadeData?.direction || 'Vertical') === 'Horizontal' ? 'selected' : ''}>Horizontal</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>
            ` : ''}
            
            ${currentDecal.type === 'image' ? `
            <div class="decal-edit-section">
              <h6 class="decal-edit-section-title">
                <i class="bi bi-image me-2"></i>Image
              </h6>
              <div class="decal-control-group">
                <div class="control-row">
                  <div class="control-input-group" style="width: 100%;">
                    <div class="image-thumbnail-container" onclick="replaceImageDecal()" 
                         onmouseover="this.style.borderColor='#6366f1'; this.style.background='#f1f5f9'" 
                         onmouseout="this.style.borderColor='#e5e7eb'; this.style.background='#f8f9fa'"
                         style="cursor: pointer; border: 2px solid #e5e7eb; border-radius: 8px; padding: 8px; background: #f8f9fa; transition: all 0.2s ease; width: 100%;">
                      <img id="current-image-thumbnail" 
                           src="${currentDecal.imageUrl || ''}" 
                           alt="Current Image" 
                           style="width: 100%; height: 80px; object-fit: contain; border-radius: 4px; background: #fff;">
                      <div style="margin-top: 6px; text-align: center;">
                        <small style="color: #6b7280; font-size: 11px;">
                          <i class="bi bi-arrow-repeat me-1"></i>Click to replace
                        </small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            ` : ''}
            
            <div class="decal-edit-section">
              <h6 class="decal-edit-section-title">
                <i class="bi bi-arrows-move me-2"></i>Position
              </h6>
              <div class="decal-control-group">
                <div class="control-row">
                  <label class="control-label">X Position</label>
                  <div class="control-input-group">
                    <input type="range" class="form-range decal-range" min="-0.3" max="1.3" step="0.01" 
                           value="${currentDecal.position.x}" 
                           data-axis="x" data-property="position" data-display="pos-x-value">
                    <span class="value-display" id="pos-x-value">${Math.round(
                      currentDecal.position.x * 100
                    )}%</span>
                  </div>
                </div>
                <div class="control-row">
                  <label class="control-label">Y Position</label>
                  <div class="control-input-group">
                    <input type="range" class="form-range decal-range" min="-0.3" max="1.3" step="0.01" 
                           value="${currentDecal.position.y}" 
                           data-axis="y" data-property="position" data-display="pos-y-value">
                    <span class="value-display" id="pos-y-value">${Math.round(
                      currentDecal.position.y * 100
                    )}%</span>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="decal-edit-section">
              <h6 class="decal-edit-section-title">
                <i class="bi bi-aspect-ratio me-2"></i>Size & Rotation
              </h6>
              <div class="decal-control-group">
                <div class="control-row">
                  <label class="control-label">Size</label>
                  <div class="control-input-group">
                    <input type="range" class="form-range decal-range" min="0.1" max="1.3" step="0.01" 
                           value="${currentDecal.size.x}" 
                           data-property="size" data-display="size-value">
                    <span class="value-display" id="size-value">${Math.round(
                      currentDecal.size.x * 100
                    )}%</span>
                  </div>
                </div>
                <div class="control-row">
                  <label class="control-label">Rotation</label>
                  <div class="control-input-group">
                    <input type="range" class="form-range decal-range" min="-180" max="180" step="1" 
                           value="${currentDecal.rotation}" 
                           data-property="rotation" data-display="rotation-value">
                    <span class="value-display" id="rotation-value">${
                      currentDecal.rotation
                    }°</span>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="decal-edit-section">
              <h6 class="decal-edit-section-title">
                <i class="bi bi-transparency me-2"></i>Appearance
              </h6>
              <div class="decal-control-group">
                <div class="control-row">
                  <label class="control-label">Opacity</label>
                  <div class="control-input-group">
                    <input type="range" class="form-range decal-range" min="0" max="1" step="0.01" 
                           value="${currentDecal.opacity}" 
                           data-property="opacity" data-display="opacity-value">
                    <span class="value-display" id="opacity-value">${Math.round(
                      currentDecal.opacity * 100
                    )}%</span>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="decal-edit-section">
              <h6 class="decal-edit-section-title">
                <i class="bi bi-symmetry-horizontal me-2"></i>Transform
              </h6>
              <div class="decal-control-group">
                <div class="flip-controls">
                  <button class="btn btn-flip ${
                    currentDecal.flipX ? "btn-primary border-primary" : "btn-outline-secondary"
                  }" 
                          onclick="toggleDecalFlip('x')">
                    <i class="bi bi-arrow-left-right"></i>
                    <span style="font-size: 10px;">Flip Horizontal</span>
                  </button>
                  <button class="btn btn-flip ${
                    currentDecal.flipY ? "btn-primary border-primary" : "btn-outline-secondary"
                  }" 
                          onclick="toggleDecalFlip('y')">
                    <i class="bi bi-arrow-down-up"></i>
                    <span style="font-size: 10px;">Flip Vertical</span>
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  `;

  // Mark that we're in decal edit mode
  window.inDecalEditMode = true;

  // Replace content with animation
  designContent.fadeOut(200, function () {
    designContent.html(editorHTML);
    designContent.fadeIn(300);

    // Attach event handlers
    attachDecalEditEventHandlers();
    
    // Populate font selector if text decal
    if (currentDecal.type === 'text') {
      populateTextFontSelector();
    }
  });
}

/**
 * Exit full-screen decal edit mode
 */
function exitDecalEditMode() {
  const designContent = $(".design-content");

  // Mark that we're no longer in decal edit mode
  window.inDecalEditMode = false;

  // Restore original content with animation
  designContent.fadeOut(200, function () {
    if (window.originalDesignContent) {
      designContent.html(window.originalDesignContent);
      delete window.originalDesignContent;
    }
    designContent.fadeIn(300);

    // Update all UI sections to re-establish event handlers
    updateColorControls();
    updateMaterialOptions();
    updateDecalsList();
  });

  // Clear current decal selection
  currentDecal = null;
}

/**
 * Attach event handlers for the full-screen decal editor
 */
function attachDecalEditEventHandlers() {
  // Add event handlers for range sliders
  $(".decal-range").on("input", function (e) {
    if (!currentDecal) return;

    const property = $(this).data("property");
    const value = parseFloat($(this).val());
    const displayId = $(this).data("display");

    // Update the value display
    if (displayId) {
      let displayValue;
      if (
        property === "position" ||
        property === "size" ||
        property === "opacity"
      ) {
        displayValue = Math.round(value * 100) + "%";
      } else if (property === "rotation") {
        displayValue = Math.round(value) + "°";
      }
      $(`#${displayId}`).text(displayValue);
    }

    if (property === "position") {
      const axis = $(this).data("axis");
      updateDecalPosition(axis, value);
    } else if (property === "size") {
      updateDecalSize(value);
    } else if (property === "rotation") {
      updateDecalRotation(value);
    } else if (property === "opacity") {
      updateDecalOpacity(value);
    }
  });

  // Disable orbit controls when using sliders
  $(".decal-range")
    .on("mouseenter", function () {
      if (controls) controls.enabled = false;
    })
    .on("mouseleave", function () {
      if (controls) controls.enabled = true;
    });
}

/**
 * Set decal property
 */
function setDecalProperty(property, value) {
  if (!currentDecal) return;

  currentDecal[property] = value;

  // Re-render layer with updated decal
  renderLayer();
}

/**
 * Check if current layer has reached the maximum number of decals (14)
 */
function isMaxDecalsReached() {
  if (!currentLayer || !currentLayer.decals) {
    return false;
  }
  return currentLayer.decals.length >= 14;
}

/**
 * Show dialog when max decals limit is reached
 */
function showMaxDecalsDialog(layerName) {
  // Create Bootstrap modal for max decals warning
  const modalHtml = `
    <div class="modal fade" id="maxDecalsModal" tabindex="-1" aria-labelledby="maxDecalsModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="maxDecalsModalLabel">Maximum Elements Reached</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            The maximum number of elements have been added to <strong>${layerName}</strong>. You can add up to 14 design elements per layer.
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
          </div>
        </div>
      </div>
    </div>
  `;
  
  // Remove existing modal if it exists
  const existingModal = document.getElementById('maxDecalsModal');
  if (existingModal) {
    existingModal.remove();
  }
  
  // Add modal to document
  document.body.insertAdjacentHTML('beforeend', modalHtml);
  
  // Show the modal
  const maxDecalsModal = new bootstrap.Modal(document.getElementById('maxDecalsModal'));
  maxDecalsModal.show();
  
  // Clean up modal after it's hidden
  document.getElementById('maxDecalsModal').addEventListener('hidden.bs.modal', function () {
    this.remove();
  });
}

/**
 * Add image decal
 */
function addImageDecal() {
  if (!currentLayer) {
    alert("Please select a layer first");
    return;
  }

  // Check if current layer can add images
  if (!currentLayer.meshSettings || !currentLayer.meshSettings.canAddImages) {
    alert("This layer does not support adding designs");
    return;
  }

  // Check if max decals limit reached
  if (isMaxDecalsReached()) {
    showMaxDecalsDialog(currentLayer.name);
    return;
  }

  // Open image bank modal
  openImageBank();
}

/**
 * Add text decal
 */
async function addTextDecal() {
  if (!currentLayer) {
    alert("Please select a layer first");
    return;
  }

  // Check if current layer can add images
  if (!currentLayer.meshSettings || !currentLayer.meshSettings.canAddImages) {
    alert("This layer does not support adding designs");
    return;
  }

  // Check if max decals limit reached
  if (isMaxDecalsReached()) {
    showMaxDecalsDialog(currentLayer.name);
    return;
  }

  // Create text decal with default values
  const text = 'Sample Text';
  const font = 'Roboto';
  const color = '#000000';
  const letterSpacing = 0;
  const borderWidth = 0;
  const borderColor = '#000000';
  
  // Create basic texture immediately (will be updated when fonts load)
  const placeholderTexture = createPlaceholderTextTexture(text, font, color);
  
  // Create new decal immediately
  const decal = {
    id: generateId(),
    name: text,
    type: 'text',
    text: text,
    font: font,
    color: color,
    letterSpacing: letterSpacing,
    borderWidth: borderWidth,
    borderColor: borderColor,
    texture: placeholderTexture,
    position: { x: 0.5, y: 0.5 },
    size: { x: 0.4, y: 0.2 },
    rotation: 0,
    opacity: 1,
    flipX: false,
    flipY: false,
    aspectLocked: true,
    isLoadingFont: true, // Flag to indicate font is still loading
    textData: {
      text: text,
      font: font,
      color: color,
      letterSpacing: letterSpacing,
      borderWidth: borderWidth,
      borderColor: borderColor
    }
  };
  
  currentLayer.decals.push(decal);
  setCurrentDecal(decal.id);
  renderLayer();
  updateDecalsList();
  
  // Enter edit mode immediately
  enterDecalEditMode();
  
  // Update texture in background when fonts are ready
  updateTextDecalWhenFontsReady(decal);
}

/**
 * Blend two colors based on mix ratio
 * @param {string} baseColor - Base color in hex format (#RRGGBB)
 * @param {string} blendColor - Blend color in hex format (#RRGGBB) 
 * @param {number} mixRatio - Mix ratio (0-1, where 0 = baseColor, 1 = blendColor)
 * @returns {string} Blended color in hex format
 */
function blendColors(baseColor, blendColor, mixRatio) {
  // Convert hex to RGB
  const hexToRgb = (hex) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  };

  // Convert RGB to hex
  const rgbToHex = (r, g, b) => {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  };

  const base = hexToRgb(baseColor);
  const blend = hexToRgb(blendColor);
  
  if (!base || !blend) {
    console.warn('Invalid color format in blendColors');
    return baseColor;
  }

  // Linear interpolation
  const r = Math.round(base.r + (blend.r - base.r) * mixRatio);
  const g = Math.round(base.g + (blend.g - base.g) * mixRatio);
  const b = Math.round(base.b + (blend.b - base.b) * mixRatio);

  return rgbToHex(r, g, b);
}

/**
 * Create enhanced fade texture with customizable parameters
 * @param {Object} options - Fade texture options
 * @param {string} options.baseColor - Base color in hex format
 * @param {string} options.blendColor - Blend color in hex format
 * @param {number} options.fadeStart - Where fade starts (0-1)
 * @param {number} options.mixRatio - How much to mix colors (0-1)
 * @param {string} options.direction - 'Vertical' or 'Horizontal'
 * @returns {THREE.CanvasTexture} Generated fade texture
 */
function createFadeTexture({
  baseColor = '#000000',
  blendColor = '#ffffff', 
  fadeStart = 0.4,
  mixRatio = 0.5,
  direction = 'Vertical'
}) {
  debugLog('Creating fade texture with options:', { baseColor, blendColor, fadeStart, mixRatio, direction });

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = 2048;
  canvas.height = 2048;
  const ctx = canvas.getContext('2d');
  
  // Clear canvas
  ctx.clearRect(0, 0, 2048, 2048);
  
  // Create the gradient
  let gradient;
  if (direction === 'Vertical') {
    gradient = ctx.createLinearGradient(0, 0, 0, 2048);
  } else {
    gradient = ctx.createLinearGradient(0, 0, 2048, 0);
  }

  // Calculate blended color based on mixRatio
  const blendedColor = blendColors(baseColor, blendColor, mixRatio);

  // Add color stops
  gradient.addColorStop(fadeStart, baseColor);
  gradient.addColorStop(1, blendedColor);

  // Fill the canvas with the gradient
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 2048, 2048);

  // Create and return Three.js texture
  const texture = new THREE.CanvasTexture(canvas);
  texture.flipY = false;
  texture.needsUpdate = true;
  
  debugLog('Fade texture created successfully');
  return texture;
}

/**
 * Add fade decal
 */
function addFadeDecal() {
  if (!currentLayer) {
    alert("Please select a layer first");
    return;
  }

  // Check if current layer can add images
  if (!currentLayer.meshSettings || !currentLayer.meshSettings.canAddImages) {
    alert("This layer does not support adding designs");
    return;
  }

  // Check if max decals limit reached
  if (isMaxDecalsReached()) {
    showMaxDecalsDialog(currentLayer.name);
    return;
  }

  // Default fade settings
  const fadeData = {
    baseColor: '#000000',
    blendColor: '#ffffff',
    fadeStart: 0.4,
    mixRatio: 0.5,
    direction: 'Vertical'
  };

  // Create enhanced fade texture
  const texture = createFadeTexture(fadeData);

  const decal = {
    id: generateId(),
    name: "Fade Effect",
    type: "fade",
    texture: texture,
    position: { x: 0.5, y: 0.5 },
    size: { x: 1.2, y: 1.2 },
    rotation: 0,
    opacity: 0.7,
    flipX: false,
    flipY: false,
    aspectLocked: true,
    fadeData: fadeData
  };

  currentLayer.decals.unshift(decal);
  setCurrentDecal(decal.id);
  renderLayer();
  updateDecalsList();

  debugLog("Fade decal added");
}

/**
 * Show delete confirmation dialog
 */
function deleteDecal(decalId) {
  if (!currentLayer) return;

  const decal = currentLayer.decals.find((d) => d.id === decalId);
  if (!decal) return;

  // Set decal info in modal
  document.getElementById('delete-decal-name').textContent = decal.name;
  
  // Store decal ID for confirmation
  window.pendingDeleteDecalId = decalId;
  
  // Show modal
  const modal = new bootstrap.Modal(document.getElementById('deleteDecalModal'));
  modal.show();
}

/**
 * Actually delete the decal after confirmation
 */
function confirmDeleteDecal() {
  if (!currentLayer || !window.pendingDeleteDecalId) return;

  const decalId = window.pendingDeleteDecalId;
  const index = currentLayer.decals.findIndex((d) => d.id === decalId);
  
  if (index > -1) {
    currentLayer.decals.splice(index, 1);

    if (currentDecal && currentDecal.id === decalId) {
      currentDecal = null;
    }

    renderLayer();
    updateDecalsList();

    debugLog("Decal deleted:", decalId);
  }
  
  // Clean up
  window.pendingDeleteDecalId = null;
  
  // Hide modal
  const modal = bootstrap.Modal.getInstance(document.getElementById('deleteDecalModal'));
  modal.hide();
}

/**
 * Duplicate decal
 */
function duplicateDecal(decalId) {
  if (!currentLayer) return;

  const originalDecal = currentLayer.decals.find((d) => d.id === decalId);
  if (!originalDecal) return;

  // Check if max decals limit reached
  if (isMaxDecalsReached()) {
    showMaxDecalsDialog(currentLayer.name);
    return;
  }

  const newDecal = {
    ...originalDecal,
    id: generateId(),
    name: originalDecal.name + " Copy",
    position: {
      x: originalDecal.position.x + 0.1,
      y: originalDecal.position.y + 0.1,
    },
    aspectLocked: originalDecal.aspectLocked || true,
  };

  currentLayer.decals.push(newDecal);
  setCurrentDecal(newDecal.id);
  renderLayer();
  updateDecalsList();

  debugLog("Decal duplicated");
}

/**
 * Duplicate decal and stay in edit mode for the new decal
 */
function duplicateDecalAndStayInEdit(decalId) {
  if (!currentLayer) return;

  const originalDecal = currentLayer.decals.find((d) => d.id === decalId);
  if (!originalDecal) return;

  // Check if max decals limit reached
  if (isMaxDecalsReached()) {
    showMaxDecalsDialog(currentLayer.name);
    return;
  }

  const newDecal = {
    ...originalDecal,
    id: generateId(),
    name: originalDecal.name + " Copy",
    position: {
      x: originalDecal.position.x + 0.1,
      y: originalDecal.position.y + 0.1,
    },
    aspectLocked: originalDecal.aspectLocked || true,
  };

  currentLayer.decals.push(newDecal);
  setCurrentDecal(newDecal.id);
  renderLayer();
  updateDecalsList();
  
  // Re-enter edit mode for the new decal
  enterDecalEditMode();

  debugLog("Decal duplicated and staying in edit mode");
}

/**
 * Move decal up in the list (decrease index)
 */
function moveDecalUp(decalId) {
  if (!currentLayer || !currentLayer.decals) return;
  
  const index = currentLayer.decals.findIndex(d => d.id === decalId);
  if (index <= 0) return; // Already at top or not found
  
  // Swap with previous item
  const temp = currentLayer.decals[index];
  currentLayer.decals[index] = currentLayer.decals[index - 1];
  currentLayer.decals[index - 1] = temp;
  
  updateDecalsList();
  renderLayer();
  
  debugLog("Moved decal up");
}

/**
 * Move decal down in the list (increase index)
 */
function moveDecalDown(decalId) {
  if (!currentLayer || !currentLayer.decals) return;
  
  const index = currentLayer.decals.findIndex(d => d.id === decalId);
  if (index === -1 || index >= currentLayer.decals.length - 1) return; // Not found or already at bottom
  
  // Swap with next item
  const temp = currentLayer.decals[index];
  currentLayer.decals[index] = currentLayer.decals[index + 1];
  currentLayer.decals[index + 1] = temp;
  
  updateDecalsList();
  renderLayer();
  
  debugLog("Moved decal down");
}

/**
 * Format layer name for display (replace underscores with spaces)
 */
function formatLayerName(layerName) {
  return layerName.replace(/_/g, ' ');
}

/**
 * Show layer menu for moving/copying decals
 */
function showDecalLayerMenu(decalId, buttonElement) {
  const decal = currentLayer.decals.find(d => d.id === decalId);
  if (!decal) return;
  
  // Get all layers that can accept images (excluding current layer)
  const availableLayers = Object.values(layers).filter(layer => 
    layer.meshSettings && 
    layer.meshSettings.canAddImages && 
    layer !== currentLayer
  );
  
  if (availableLayers.length === 0) {
    alert("No other layers available that can accept designs");
    return;
  }
  
  // Create popover content
  let menuContent = '<div class="decal-layer-menu">';
  
  // Move to other layer section
  menuContent += '<div class="decal-layer-menu-section">';
  menuContent += '<div class="decal-layer-menu-section-header">Move to other layer</div>';
  
  availableLayers.forEach(layer => {
    const displayName = formatLayerName(layer.name);
    menuContent += `
      <div class="decal-layer-menu-item" onclick="moveDecalToLayer('${decalId}', '${layer.name}')">
        <div class="decal-layer-menu-layer-name">${displayName}</div>
      </div>
    `;
  });
  
  menuContent += '</div>';
  
  // Copy to other layers section
  menuContent += '<div class="decal-layer-menu-section">';
  menuContent += '<div class="decal-layer-menu-section-header">Copy to other layers</div>';
  
  // Add "All Layers" option (all other layers, excluding current)
  const allOtherLayers = availableLayers.map(l => l.name).join(',');
  menuContent += `
    <div class="decal-layer-menu-item" onclick="copyDecalToAllLayers('${decalId}', '${allOtherLayers}')">
      <div class="decal-layer-menu-layer-name"><strong>All Layers</strong></div>
    </div>
  `;
  
  // Add individual layer options
  availableLayers.forEach(layer => {
    const displayName = formatLayerName(layer.name);
    menuContent += `
      <div class="decal-layer-menu-item" onclick="copyDecalToLayer('${decalId}', '${layer.name}')">
        <div class="decal-layer-menu-layer-name">${displayName}</div>
      </div>
    `;
  });
  
  menuContent += '</div>';
  menuContent += '</div>';
  
  // Remove any existing popover
  $('.decal-layer-popover').remove();
  
  // Create and show popover
  const popover = $(`<div class="decal-layer-popover">${menuContent}</div>`);
  $('body').append(popover);
  
  // Position popover relative to button
  const buttonRect = buttonElement.getBoundingClientRect();
  popover.css({
    position: 'fixed',
    left: buttonRect.left - 150,
    top: buttonRect.bottom + 5,
    zIndex: 10000
  });
  
  // Hide popover when clicking outside
  $(document).on('click.decal-popover', function(e) {
    if (!$(e.target).closest('.decal-layer-popover, .bi-layers').length) {
      popover.remove();
      $(document).off('click.decal-popover');
    }
  });
}

/**
 * Render a specific layer (temporarily switch to it)
 */
function renderSpecificLayer(layerName) {
  const originalLayer = currentLayer;
  const targetLayer = layers[layerName];
  
  if (!targetLayer) return;
  
  // Temporarily switch to target layer
  currentLayer = targetLayer;
  renderLayer();
  
  // Switch back to original layer
  currentLayer = originalLayer;
}

/**
 * Move decal to another layer
 */
function moveDecalToLayer(decalId, targetLayerName) {
  const decal = currentLayer.decals.find(d => d.id === decalId);
  const targetLayer = layers[targetLayerName];
  
  if (!decal || !targetLayer) return;
  
  // Check if target layer has reached max decals limit
  if (targetLayer.decals && targetLayer.decals.length >= 14) {
    showMaxDecalsDialog(targetLayerName);
    return;
  }
  
  // Remove from current layer
  const index = currentLayer.decals.findIndex(d => d.id === decalId);
  currentLayer.decals.splice(index, 1);
  
  // Add to target layer
  targetLayer.decals.push(decal);
  
  // Clear current decal if it was moved
  if (currentDecal && currentDecal.id === decalId) {
    currentDecal = null;
  }
  
  // Re-render both current layer and target layer
  updateDecalsList();
  renderLayer(); // Render current layer
  renderSpecificLayer(targetLayerName); // Render target layer
  
  // Close decal control options since the decal is no longer on this layer
  if (window.inDecalEditMode) {
    exitDecalEditMode();
  }
  
  $('.decal-layer-popover').remove();
  
  debugLog(`Moved decal to layer: ${targetLayerName} and closed control options`);
}

/**
 * Copy decal to another layer
 */
function copyDecalToLayer(decalId, targetLayerName) {
  const decal = currentLayer.decals.find(d => d.id === decalId);
  const targetLayer = layers[targetLayerName];
  
  if (!decal || !targetLayer) return;
  
  // Check if target layer has reached max decals limit
  if (targetLayer.decals && targetLayer.decals.length >= 14) {
    showMaxDecalsDialog(targetLayerName);
    return;
  }
  
  // Create deep copy of decal
  const newDecal = {
    ...decal,
    id: generateId(),
    name: decal.name + " Copy",
    // Deep copy position and size objects to avoid reference sharing
    position: { ...decal.position },
    size: { ...decal.size }
  };
  
  // Deep copy textData if it exists
  if (decal.textData) {
    newDecal.textData = { ...decal.textData };
  }
  
  // Deep copy fadeData if it exists
  if (decal.fadeData) {
    newDecal.fadeData = { ...decal.fadeData };
  }
  
  // Add to target layer
  targetLayer.decals.push(newDecal);
  
  // Re-render target layer to show the new decal
  renderSpecificLayer(targetLayerName);
  
  $('.decal-layer-popover').remove();
  
  debugLog(`Copied decal to layer: ${targetLayerName}`);
}

/**
 * Copy decal to all available layers
 */
function copyDecalToAllLayers(decalId, layerNamesString) {
  const decal = currentLayer.decals.find(d => d.id === decalId);
  if (!decal) return;
  
  const layerNames = layerNamesString.split(',');
  let copiedCount = 0;
  
  layerNames.forEach(layerName => {
    const targetLayer = layers[layerName];
    if (targetLayer) {
      // Check if target layer has reached max decals limit
      if (targetLayer.decals && targetLayer.decals.length >= 14) {
        debugLog(`Skipping layer ${layerName} - max decals limit reached`);
        return; // Skip this layer
      }
      
      // Create deep copy of decal
      const newDecal = {
        ...decal,
        id: generateId(),
        name: decal.name + " Copy",
        // Deep copy position and size objects to avoid reference sharing
        position: { ...decal.position },
        size: { ...decal.size }
      };
      
      // Deep copy textData if it exists
      if (decal.textData) {
        newDecal.textData = { ...decal.textData };
      }
      
      // Deep copy fadeData if it exists
      if (decal.fadeData) {
        newDecal.fadeData = { ...decal.fadeData };
      }
      
      // Add to target layer
      targetLayer.decals.push(newDecal);
      
      // Re-render target layer to show the new decal
      renderSpecificLayer(layerName);
      
      copiedCount++;
    }
  });
  
  $('.decal-layer-popover').remove();
  
  debugLog(`Copied decal to ${copiedCount} layers`);
}

/**
 * Helper function for shader to generate switch cases
 */
function generateSwitchCases(numDecals) {
  let switchCases = "";
  for (let i = 0; i < numDecals; i++) {
    switchCases += `
            case ${i}:
                texColor = texture2D(decalImages[${i}], uv);
                break;
        `;
  }
  return switchCases;
}

/**
 * Render layer with decals using shader-based approach
 */
function renderLayer() {
  if (!currentLayer) return;

  const mesh = currentLayer.mesh;
  const allDecals = currentLayer.decals;
  
  // Filter out decals without textures
  const decals = allDecals.filter(d => d.texture);

  debugLog("Rendering layer with", decals.length, "decals using shader (filtered from", allDecals.length, "total)");

  // If no decals with textures, reset material to default
  if (decals.length === 0) {
    mesh.material.onBeforeCompile = () => {};
    mesh.material.needsUpdate = true;
    return;
  }

  // Ensure Shader is not cached
  mesh.material.customProgramCacheKey = () =>
    Math.random().toString(36).substring(2, 15);

  // Hook Shader
  mesh.material.onBeforeCompile = (shader) => {
    // Set Uniforms
    shader.uniforms.decalImages = { value: decals.map((d) => d.texture) };
    shader.uniforms.decalPositions = {
      value: decals.map((d) => new THREE.Vector2(d.position.x, d.position.y)),
    };
    shader.uniforms.decalRotations = {
      value: decals.map((d) => (d.rotation * Math.PI) / 180),
    };
    shader.uniforms.decalFlipXs = { value: decals.map((d) => d.flipX) };
    shader.uniforms.decalFlipYs = { value: decals.map((d) => d.flipY) };
    shader.uniforms.decalOpacities = { value: decals.map((d) => d.opacity) };
    shader.uniforms.decalSizes = {
      value: decals.map((d) => {
        if (d.aspectLocked && d.texture && d.texture.image && d.texture.image.width && d.texture.image.height) {
          return new THREE.Vector2(
            d.size.x,
            d.size.x * (d.texture.image.height / d.texture.image.width) // Maintain aspect ratio of image
          );
        } else {
          return new THREE.Vector2(d.size.x, d.size.y);
        }
      }),
    };
    shader.uniforms.minX = { value: parseFloat(currentLayer.minX) };
    shader.uniforms.maxX = { value: parseFloat(currentLayer.maxX) };
    shader.uniforms.minY = { value: parseFloat(currentLayer.minY) };
    shader.uniforms.maxY = { value: parseFloat(currentLayer.maxY) };

    // Adjust Vertex Shader
    shader.vertexShader = `
    ${shader.vertexShader.replace("void main", "void originalMain")}
    varying vec2 vDecalUv;
    void main() {
        vDecalUv = uv;
        originalMain();
    }
    `;

    // Define uniforms/vars in global scope
    shader.fragmentShader = shader.fragmentShader.replace(
      "void main()",
      `
      varying vec2 vDecalUv;
      #define MAX_DECALS ${decals.length}
      #if MAX_DECALS > 0
          uniform sampler2D decalImages[MAX_DECALS];
          uniform vec2 decalPositions[MAX_DECALS];
          uniform vec2 decalSizes[MAX_DECALS];
          uniform float decalRotations[MAX_DECALS];
          uniform bool decalFlipXs[MAX_DECALS];
          uniform bool decalFlipYs[MAX_DECALS];
          uniform float decalOpacities[MAX_DECALS];
      #endif
      uniform float minX;
      uniform float maxX;
      uniform float minY;
      uniform float maxY;
      void main()
      `
    );

    // Replace normal texture mapping with custom one
    shader.fragmentShader = shader.fragmentShader.replace(
      "#include <map_fragment>",
      `
      #if MAX_DECALS > 0
          for (int i = 0; i < MAX_DECALS; i++) {
              vec2 originalUV = vDecalUv;

              vec2 rotatedUV = vDecalUv - decalPositions[i]; // Translate to origin
              float c = cos(decalRotations[i]);
              float s = sin(decalRotations[i]);
              rotatedUV = vec2(
                  rotatedUV.x * c - rotatedUV.y * s,
                  rotatedUV.x * s + rotatedUV.y * c
              );
              rotatedUV += decalPositions[i]; // Translate back to original position

              vec2 uv = (rotatedUV - decalPositions[i]) / decalSizes[i] + 0.5;
              
              if (decalFlipXs[i]) {
                uv.x = 1.0 - uv.x;
              }
              if (decalFlipYs[i]) {
                uv.y = 1.0 - uv.y;
              }

              vec4 texColor = vec4(0.0);
              switch(i) {
                ${generateSwitchCases(decals.length)}
              }
              if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0 && originalUV.x >= minX && originalUV.x <= maxX && originalUV.y >= minY && originalUV.y <= maxY && gl_FrontFacing) {
                float existingAlpha = diffuseColor.a;
                float finalAlpha = existingAlpha * (1.0 - texColor.a * decalOpacities[i]) + texColor.a * decalOpacities[i];

                  // Check if the final alpha is less than a very small threshold, treat it as fully transparent
                  if (finalAlpha < 0.001) {
                      diffuseColor.a = 0.0;
                  } else {
                      // Blend the colors using the calculated alpha value
                      diffuseColor.rgb = (texColor.rgb * texColor.a * decalOpacities[i] + diffuseColor.rgb * existingAlpha * (1.0 - texColor.a * decalOpacities[i])) / finalAlpha;
                      diffuseColor.a = finalAlpha;
                  }
              }
          }
      #endif
      `
    );
  };

  // Trigger Rerender of Material
  mesh.material.needsUpdate = true;
}

/**
 * Initialize UI events
 */
function initUI() {
  // Window resize
  $(window).on("resize", function () {
    setTimeout(onWindowResize, 100);
  });

  // Initial resize and setup
  setTimeout(onWindowResize, 100);
  initCart();

  // Initialize account popover
  initAccountPopover();
}

/**
 * Initialize account popover
 */
function initAccountPopover() {
  const accountBtn = document.getElementById("account-popover-btn");
  if (!accountBtn) return;

  // Get user data from PHP (with safety checks)
  const user = window.phpData?.user || null;
  const isGuest = window.phpData?.isGuest || true;

  let popoverContent = "";

  if (user) {
    // User is logged in
    popoverContent = `
      <div class="p-2">
        <div class="mb-3">
          <strong class="d-block text-dark">${user.email}</strong>
          <small class="text-muted">Logged in</small>
        </div>
        <div class="d-grid gap-2">
          <a href="/account" class="btn btn-sm btn-outline-primary">
            <i class="bi bi-person me-1"></i> My Account
          </a>
          <a href="/designs" class="btn btn-sm btn-outline-secondary">
            <i class="bi bi-palette me-1"></i> My Designs
          </a>
          <a href="/orders" class="btn btn-sm btn-outline-secondary">
            <i class="bi bi-bag me-1"></i> My Orders
          </a>
          <hr class="my-2">
          <a href="/logout" class="btn btn-sm btn-outline-danger">
            <i class="bi bi-box-arrow-right me-1"></i> Logout
          </a>
        </div>
      </div>
    `;
  } else {
    // User is not logged in (guest)
    popoverContent = `
      <div class="p-2">
        <div class="mb-3">
          <strong class="d-block text-dark">Guest User</strong>
          <small class="text-muted">Not logged in</small>
        </div>
        <p class="small text-muted mb-3">
          Sign in to save your designs and track orders
        </p>
        <div class="d-grid gap-2">
          <a href="/login" class="btn btn-sm btn-primary">
            <i class="bi bi-box-arrow-in-right me-1"></i> Login
          </a>
          <a href="/register" class="btn btn-sm btn-outline-primary">
            <i class="bi bi-person-plus me-1"></i> Register
          </a>
        </div>
      </div>
    `;
  }

  // Initialize Bootstrap popover
  const popover = new bootstrap.Popover(accountBtn, {
    content: popoverContent,
    html: true,
    sanitize: false,
    customClass: "account-popover",
  });

  // Close popover when clicking outside
  document.addEventListener("click", function (e) {
    if (
      !accountBtn.contains(e.target) &&
      !document.querySelector(".popover")?.contains(e.target)
    ) {
      popover.hide();
    }
  });
}

/**
 * Toggle mobile panel
 */
function togglePanel() {
  $("#right-panel").toggleClass("open");
}

/**
 * Utility functions
 */
function generateId() {
  return Math.random().toString(36).substring(2, 15);
}

/**
 * View controls with model fitting
 */
function rotateView(direction) {
  if (!window.phpData.product || !loaded) return;

  // Find the model in the scene
  const model = scene.children.find(
    (child) => child.type === "Group" || child.type === "Object3D"
  );

  if (!model) return;

  const box = new THREE.Box3().setFromObject(model);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());

  // Calculate proper distance based on camera FOV and model size
  const container = document.getElementById("canvas-container");
  const aspect = container.clientWidth / container.clientHeight;
  const horizontalFOV =
    2 * Math.atan(Math.tan((camera.fov * Math.PI) / 360) * aspect);
  const verticalFOV = (camera.fov * Math.PI) / 180;

  const horizontalDistance = size.x / (2 * Math.tan(horizontalFOV / 2));
  const verticalDistance = size.y / (2 * Math.tan(verticalFOV / 2));
  const depthDistance = size.z * 0.5;

  const distance =
    Math.max(horizontalDistance, verticalDistance, depthDistance) * 1.5;

  let position;
  switch (direction) {
    case "front":
      position = new THREE.Vector3(0, 0, distance);
      break;
    case "back":
      position = new THREE.Vector3(0, 0, -distance);
      break;
    case "left":
      position = new THREE.Vector3(distance, 0, 0);
      break;
    case "right":
      position = new THREE.Vector3(-distance, 0, 0);
      break;
  }

  camera.position.copy(position.add(center));
  controls.target.copy(center);
  controls.update();
}

/**
 * Camera rotation controls
 */
function rotateCamera(direction) {
  if (!controls || !camera) return;

  const rotationAmount = Math.PI / 6; // 30 degrees
  const spherical = new THREE.Spherical();
  const offset = new THREE.Vector3();

  // Get current spherical coordinates
  offset.copy(camera.position).sub(controls.target);
  spherical.setFromVector3(offset);

  // Apply rotation
  if (direction === "left") {
    spherical.theta += rotationAmount;
  } else if (direction === "right") {
    spherical.theta -= rotationAmount;
  }

  // Update camera position
  offset.setFromSpherical(spherical);
  camera.position.copy(controls.target).add(offset);
  controls.update();
}

/**
 * Camera zoom controls
 */
function zoomCamera(direction) {
  if (!controls || !camera) return;

  const zoomFactor = 0.1;
  const offset = new THREE.Vector3();

  offset.copy(camera.position).sub(controls.target);

  if (direction === "in") {
    offset.multiplyScalar(1 - zoomFactor);
  } else if (direction === "out") {
    offset.multiplyScalar(1 + zoomFactor);
  }

  // Respect distance limits
  const distance = offset.length();
  if (distance >= controls.minDistance && distance <= controls.maxDistance) {
    camera.position.copy(controls.target).add(offset);
    controls.update();
  }
}

/**
 * Open tutorials (placeholder)
 */
function openTutorials() {
  alert(
    "Tutorials coming soon! This will show interactive guides for using the 3D designer."
  );
}

/**
 * Top bar functions
 */
/**
 * Show exit confirmation modal
 */
function confirmExitDesigner() {
  const modal = new bootstrap.Modal(
    document.getElementById("exitConfirmModal")
  );
  modal.show();
}

/**
 * Exit designer (called from confirmation modal)
 */
function exitDesigner() {
  // Close the modal first
  const modal = bootstrap.Modal.getInstance(
    document.getElementById("exitConfirmModal")
  );
  if (modal) {
    modal.hide();
  }

  // Navigate away
  window.location.href = "/designs";
}

function saveDesign() {
  // Check if design name is still default
  if (designName === 'Untitled Design') {
    // Set flag to continue save after name change
    window.pendingSaveAfterNameChange = true;
    
    // Show name input modal first
    const modal = new bootstrap.Modal(document.getElementById('editDesignNameModal'));
    modal.show();
  } else {
    // Name already set, proceed with save
    performSaveDesign();
  }
}

function performSaveDesign() {
  // Show loading overlay
  showLoadingOverlay("Saving design...");

  // Capture current design data
  const designData = captureDesignData();

  // Take screenshots from different angles
  const screenshots = captureScreenshots();

  // Prepare save data
  const saveData = {
    name: designName,
    product_id: window.phpData.product.id,
    design_data: designData,
    screenshots: screenshots
  };
  
  // Add design ID if updating existing design
  if (currentDesignId) {
    saveData.design_id = currentDesignId;
  }

  // Save to server
  fetch('/api/designs.php?action=save', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(saveData)
  })
  .then(response => response.json())
  .then(data => {
    hideLoadingOverlay();
    
    if (data.success) {
      // Update current design ID if it was a new design
      if (!currentDesignId) {
        currentDesignId = data.design_id;
      }
      
      // Show success message
      const message = currentDesignId ? 'Design updated successfully!' : 'Design saved successfully!';
      showToast(message, 'success');
      debugLog('Design saved with ID:', data.design_id);
      
      // Redirect to designs page after successful save
      window.location.href = '/designs';
    } else {
      // Check if it's a duplicate name error
      if (data.error && data.error.includes('design with this name already exists')) {
        // Show specific error for duplicate names
        showToast(data.error, 'error');
        // Optionally reopen the name edit modal
        const modal = new bootstrap.Modal(document.getElementById('editDesignNameModal'));
        modal.show();
      } else {
        throw new Error(data.error || 'Failed to save design');
      }
    }
  })
  .catch(error => {
    hideLoadingOverlay();
    debugError('Error saving design:', error);
    showToast('Failed to save design. Please try again.', 'error');
  });
}

/**
 * Capture screenshots from different angles
 */
function captureScreenshots() {
  const screenshots = {};
  const views = ['front', 'back', 'left', 'right'];
  
  // Store current camera position
  const currentPosition = {
    x: camera.position.x,
    y: camera.position.y,
    z: camera.position.z
  };
  
  // Store current background and remove it for transparent screenshots
  const originalBackground = scene.background;
  scene.background = null;
  
  views.forEach(view => {
    // Rotate to specific view
    rotateView(view);
    
    // Render the scene with transparent background
    renderer.render(scene, camera);
    
    // Capture screenshot
    screenshots[view] = renderer.domElement.toDataURL('image/png');
  });
  
  // Restore camera position
  camera.position.set(currentPosition.x, currentPosition.y, currentPosition.z);
  controls.update();
  
  // Restore original background
  scene.background = originalBackground;
  
  // Render the scene to restore the normal view
  renderer.render(scene, camera);
  
  return screenshots;
}

/**
 * Show loading overlay with message and optional type
 */
function showLoadingOverlay(message = 'Loading...', type = 'loading') {
  const overlay = document.getElementById('loading-overlay');
  if (overlay) {
    const textElement = overlay.querySelector('p');
    const spinnerElement = overlay.querySelector('.spinner-border');
    const loadingContent = overlay.querySelector('.loading-content');
    
    if (textElement) {
      textElement.textContent = message;
    }
    
    // Reset any previous type classes
    if (loadingContent) {
      loadingContent.classList.remove('loading-success', 'loading-error', 'loading-default');
    }
    
    // Apply styling based on type
    if (type === 'success') {
      if (loadingContent) {
        loadingContent.classList.add('loading-success');
      }
      if (spinnerElement) {
        spinnerElement.style.display = 'none';
      }
      // Add a success icon
      if (loadingContent && !loadingContent.querySelector('.success-icon')) {
        const successIcon = document.createElement('div');
        successIcon.className = 'success-icon mb-3';
        successIcon.innerHTML = '<i class="bi bi-check-circle-fill text-success" style="font-size: 3rem;"></i>';
        loadingContent.insertBefore(successIcon, textElement);
      }
    } else if (type === 'error') {
      if (loadingContent) {
        loadingContent.classList.add('loading-error');
      }
      if (spinnerElement) {
        spinnerElement.style.display = 'none';
      }
      // Add an error icon
      if (loadingContent && !loadingContent.querySelector('.error-icon')) {
        const errorIcon = document.createElement('div');
        errorIcon.className = 'error-icon mb-3';
        errorIcon.innerHTML = '<i class="bi bi-exclamation-triangle-fill text-danger" style="font-size: 3rem;"></i>';
        loadingContent.insertBefore(errorIcon, textElement);
      }
    } else {
      // Default loading state
      if (loadingContent) {
        loadingContent.classList.add('loading-default');
      }
      if (spinnerElement) {
        spinnerElement.style.display = 'block';
      }
      // Remove any existing icons
      const existingIcons = loadingContent?.querySelectorAll('.success-icon, .error-icon');
      existingIcons?.forEach(icon => icon.remove());
    }
    
    overlay.style.display = 'flex';
  }
}

/**
 * Hide loading overlay
 */
function hideLoadingOverlay() {
  const overlay = document.getElementById('loading-overlay');
  if (overlay) {
    const loadingContent = overlay.querySelector('.loading-content');
    const spinnerElement = overlay.querySelector('.spinner-border');
    
    // Clean up any icons and reset to default state
    const existingIcons = loadingContent?.querySelectorAll('.success-icon, .error-icon');
    existingIcons?.forEach(icon => icon.remove());
    
    // Reset classes
    if (loadingContent) {
      loadingContent.classList.remove('loading-success', 'loading-error', 'loading-default');
    }
    
    // Show spinner again for next time
    if (spinnerElement) {
      spinnerElement.style.display = 'block';
    }
    
    overlay.style.display = 'none';
  }
}

/**
 * Show toast notification
 */
function showToast(message, type = 'info') {
  // Create toast element
  const toast = document.createElement('div');
  toast.className = `toast align-items-center text-white bg-${type === 'success' ? 'success' : type === 'error' ? 'danger' : 'info'} border-0`;
  toast.setAttribute('role', 'alert');
  toast.setAttribute('aria-live', 'assertive');
  toast.setAttribute('aria-atomic', 'true');
  
  toast.innerHTML = `
    <div class="d-flex">
      <div class="toast-body">
        ${message}
      </div>
      <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
    </div>
  `;
  
  // Create toast container if it doesn't exist
  let toastContainer = document.getElementById('toast-container');
  if (!toastContainer) {
    toastContainer = document.createElement('div');
    toastContainer.id = 'toast-container';
    toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
    toastContainer.style.zIndex = '11000';
    document.body.appendChild(toastContainer);
  }
  
  toastContainer.appendChild(toast);
  
  // Initialize and show toast
  const bsToast = new bootstrap.Toast(toast, {
    autohide: true,
    delay: 3000
  });
  bsToast.show();
  
  // Remove toast after it's hidden
  toast.addEventListener('hidden.bs.toast', () => {
    toast.remove();
  });
}

function takeScreenshot() {
  const dataURL = renderer.domElement.toDataURL("image/png");
  const link = document.createElement("a");
  link.download = `${designName}-screenshot.png`;
  link.href = dataURL;
  link.click();
}

/**
 * Initialize cart functionality
 */
function initCart() {
  // Cart is now modal-based, no initialization needed
}

/**
 * Initialize pricing popover
 */
function initializePricingPopover() {
  const product = window.phpData.product;

  if (!product.prices || typeof product.prices !== "object") {
    return; // No bulk pricing to show
  }

  // Create popover content
  let content =
    '<div class="pricing-breakdown"><strong>Bulk Pricing:</strong><br>';

  // Sort quantities in ascending order for display
  const quantities = Object.keys(product.prices)
    .map(Number)
    .sort((a, b) => a - b);

  quantities.forEach((qty, index) => {
    const price = product.prices[qty];
    const nextQty = quantities[index + 1];

    if (nextQty) {
      content += `${qty}-${nextQty - 1} items: $${price.toFixed(2)} each<br>`;
    } else {
      content += `${qty}+ items: $${price.toFixed(2)} each<br>`;
    }
  });

  content += "</div>";

  // Initialize Bootstrap popover
  const popoverTriggerEl = document.getElementById("pricing-info-btn");
  if (popoverTriggerEl) {
    new bootstrap.Popover(popoverTriggerEl, {
      content: content,
      html: true,
      placement: "top",
      trigger: "hover focus",
    });
  }
}

/**
 * Open cart modal
 */
function openCartModal() {
  populateModalSizes();
  updateModalTotal();
  initializePricingPopover();

  // Show modal using Bootstrap
  const modal = new bootstrap.Modal(document.getElementById("cartModal"));
  modal.show();
}

/**
 * Get price for quantity using product's quantity-based pricing
 */
function getPriceForQuantity(totalQuantity) {
  const product = window.phpData.product;

  // If product has quantity-based pricing (prices object)
  if (product.prices && typeof product.prices === "object") {
    const quantities = Object.keys(product.prices)
      .map(Number)
      .sort((a, b) => b - a);

    // Find the highest quantity tier that the total quantity meets
    for (let qty of quantities) {
      if (totalQuantity >= qty) {
        return parseFloat(product.prices[qty]);
      }
    }
  }

  // Fallback to product.price or default
  return parseFloat(product.price) || 75;
}

/**
 * Populate available sizes in modal
 */
function populateModalSizes() {
  const container = $("#size-selector-modal");
  container.empty();

  const product = window.phpData.product;

  // Check if product has sizes array, if not create default sizes
  let sizes = [];
  if (
    product.sizes &&
    Array.isArray(product.sizes) &&
    product.sizes.length > 0
  ) {
    sizes = product.sizes.map((size) => {
      // Handle both object and string formats
      if (typeof size === "object") {
        return {
          name: size.name || size.size || "Unknown",
        };
      } else {
        return {
          name: size,
        };
      }
    });
  } else {
    // Default sizes if none are defined
    sizes = [{ name: "Small" }, { name: "Medium" }, { name: "Large" }];
  }

  sizes.forEach((size) => {
    // Ensure we have valid size data
    const sizeName = size.name || size;
    // Create safe ID by replacing spaces with hyphens and converting to lowercase
    const safeId = sizeName.replace(/\s+/g, "-").toLowerCase();

    // Initialize quantity for this size
    sizeQuantities[sizeName] = 0;

    const sizeCard = $(`
      <div class="size-card-modal" data-size="${sizeName}">
        <div class="size-header-modal">
          <div class="size-name-modal">${sizeName}</div>
        </div>
        <div class="size-quantity-modal">
          <button class="qty-btn-modal minus-btn" data-size="${sizeName}">
            <i class="bi bi-dash"></i>
          </button>
          <input type="number" class="qty-input-modal" id="modal-qty-${safeId}" value="0" min="0" max="99" data-size="${sizeName}">
          <button class="qty-btn-modal plus-btn" data-size="${sizeName}">
            <i class="bi bi-plus"></i>
          </button>
        </div>
      </div>
    `);

    container.append(sizeCard);
  });

  // Bind events using event delegation for better reliability
  container
    .off("click.quantity")
    .on("click.quantity", ".minus-btn", function (e) {
      e.preventDefault();
      e.stopPropagation();
      const sizeName = $(this).data("size");
      changeModalQuantity(sizeName, -1);
    });

  container
    .off("click.quantity-plus")
    .on("click.quantity-plus", ".plus-btn", function (e) {
      e.preventDefault();
      e.stopPropagation();
      const sizeName = $(this).data("size");
      changeModalQuantity(sizeName, 1);
    });

  container
    .off("input.quantity change.quantity")
    .on("input.quantity change.quantity", ".qty-input-modal", function () {
      const sizeName = $(this).data("size");
      setModalQuantity(sizeName, this.value);
    });

  // Update initial pricing
  updateModalPricing();
}

/**
 * Change quantity for a specific size in modal
 */
function changeModalQuantity(sizeName, delta) {
  const currentQty = sizeQuantities[sizeName] || 0;
  const newQty = Math.max(0, Math.min(99, currentQty + delta));

  sizeQuantities[sizeName] = newQty;

  // Create safe ID for input selection
  const safeId = sizeName.replace(/\s+/g, "-").toLowerCase();
  $(`#modal-qty-${safeId}`).val(newQty);

  // Update card styling
  const card = $(`.size-card-modal[data-size="${sizeName}"]`);
  if (newQty > 0) {
    card.addClass("has-quantity");
  } else {
    card.removeClass("has-quantity");
  }

  updateModalPricing();
  updateModalTotal();
}

/**
 * Set quantity for a specific size in modal
 */
function setModalQuantity(sizeName, quantity) {
  const qty = Math.max(0, Math.min(99, parseInt(quantity) || 0));
  sizeQuantities[sizeName] = qty;

  // Create safe ID for input selection
  const safeId = sizeName.replace(/\s+/g, "-").toLowerCase();
  const input = $(`#modal-qty-${safeId}`);
  if (input.val() != qty) {
    input.val(qty);
  }

  // Update card styling
  const card = $(`.size-card-modal[data-size="${sizeName}"]`);
  if (qty > 0) {
    card.addClass("has-quantity");
  } else {
    card.removeClass("has-quantity");
  }

  updateModalPricing();
  updateModalTotal();
}

/**
 * Update pricing for all sizes based on total quantity
 */
function updateModalPricing() {
  // Calculate total quantity across all sizes
  let totalQuantity = 0;
  Object.values(sizeQuantities).forEach((qty) => {
    totalQuantity += parseInt(qty) || 0;
  });

  // Get price per item based on total quantity
  const pricePerItem = getPriceForQuantity(totalQuantity);

  // No longer need to update individual size prices since they're removed
  // Price is now only shown in the total section
}

/**
 * Update total price in modal
 */
function updateModalTotal() {
  let total = 0;
  let totalQuantity = 0;
  let hasItems = false;

  // Calculate total quantity and determine price
  Object.values(sizeQuantities).forEach((qty) => {
    const quantity = parseInt(qty) || 0;
    totalQuantity += quantity;
    if (quantity > 0) {
      hasItems = true;
    }
  });

  let pricePerItem = 0;
  if (hasItems) {
    pricePerItem = getPriceForQuantity(totalQuantity);
    total = pricePerItem * totalQuantity;
  } else {
    pricePerItem = getPriceForQuantity(1); // Show initial price when no items
  }

  // Update all display elements
  $("#cart-quantity-modal").text(totalQuantity);
  $("#cart-price-each-modal").text(`$${pricePerItem.toFixed(2)}`);
  $("#cart-total-modal").text(`$${total.toFixed(2)}`);

  // Enable/disable add to cart button based on whether there are items
  $("#confirm-add-cart-btn").prop("disabled", !hasItems);
}

/**
 * Confirm add to cart from modal
 */
async function confirmAddToCart() {
  // Check if any quantities are selected
  let totalItems = 0;
  let cartItems = [];

  // Calculate total quantity first to determine pricing
  Object.entries(sizeQuantities).forEach(([sizeName, quantity]) => {
    const qty = parseInt(quantity) || 0;
    if (qty > 0) {
      totalItems += qty;
    }
  });

  if (totalItems === 0) {
    alert("Please select at least one item with quantity greater than 0");
    return;
  }

  // Check if design needs a name
  const designNameInput = document.getElementById('design-name-input');
  const currentName = designNameInput?.value?.trim() || '';
  
  if (!currentName || currentName === 'Untitled Design') {
    // Prompt user to name their design
    const newName = prompt('Please give your design a name before adding to cart:', currentName || 'My Design');
    
    if (!newName || newName.trim() === '') {
      // User cancelled or entered empty name
      return;
    }
    
    // Update the design name input
    if (designNameInput) {
      designNameInput.value = newName.trim();
    }
  }

  // Show loading state
  const confirmButton = document.getElementById('confirm-add-cart-btn');
  const originalButtonText = confirmButton.innerHTML;
  confirmButton.disabled = true;
  confirmButton.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Saving & Adding to Cart...';

  try {
    // First, save the design
    debugLog("Saving design before adding to cart...");
    const designData = await saveDesignAndGetId();
    
    if (!designData.design_id) {
      throw new Error('Failed to save design');
    }

    debugLog("Design saved with ID:", designData.design_id);

    // Get price per item based on total quantity
    const pricePerItem = getPriceForQuantity(totalItems);

    // Create cart items with saved design ID
    Object.entries(sizeQuantities).forEach(([sizeName, quantity]) => {
      const qty = parseInt(quantity) || 0;
      if (qty > 0) {
        cartItems.push({
          design_id: designData.design_id,
          size: sizeName,
          quantity: qty,
        });
      }
    });

    debugLog("Adding to cart:", cartItems);

    // Add each item to cart
    const addToCartPromises = cartItems.map(async item => {
      try {
        const response = await fetch('/add-to-cart.php', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams({
            design_id: item.design_id,
            size: item.size,
            quantity: item.quantity
          })
        });
        
        const responseText = await response.text();
        console.log('Cart response for', item, ':', responseText);
        
        try {
          return JSON.parse(responseText);
        } catch (parseError) {
          console.error('Failed to parse cart response as JSON:', responseText);
          throw new Error(`Server returned invalid response: ${responseText.substring(0, 200)}...`);
        }
      } catch (error) {
        console.error('Cart request failed:', error);
        throw error;
      }
    });

    const results = await Promise.all(addToCartPromises);
    
    // Check if all additions were successful
    const hasError = results.some(result => !result.success);
    if (hasError) {
      const errorMessages = results.filter(r => !r.success).map(r => r.message).join(', ');
      throw new Error('Failed to add to cart: ' + errorMessages);
    }

    // Close modal
    const modal = bootstrap.Modal.getInstance(document.getElementById("cartModal"));
    modal.hide();

    // Reset quantities after successful add to cart
    Object.keys(sizeQuantities).forEach((sizeName) => {
      sizeQuantities[sizeName] = 0;
    });

    // Trigger cart update event before redirecting
    const cartUpdateEvent = new CustomEvent('cartUpdated', {
      detail: { count: totalItems }
    });
    document.dispatchEvent(cartUpdateEvent);
    
    // Small delay to allow cart update, then redirect
    setTimeout(() => {
      window.location.href = '/cart?added=' + designData.design_id;
    }, 100);

  } catch (error) {
    console.error('Error adding to cart:', error);
    alert('Error adding to cart: ' + error.message);
    
    // Restore button state
    confirmButton.disabled = false;
    confirmButton.innerHTML = originalButtonText;
  }
}

/**
 * Save design and return the design ID for cart operations
 */
async function saveDesignAndGetId() {
  const designName = document.getElementById('design-name-input')?.value?.trim() || 'My Design';
  
  const designData = {
    name: designName,
    product_id: window.phpData.product.id,
    design_data: captureDesignData(),
    screenshots: captureScreenshots()
  };

  const response = await fetch('/api/designs.php?action=save', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(designData)
  });

  const data = await response.json();
  
  if (!response.ok || !data.success) {
    // Check if it's a duplicate name error
    if (data.error && data.error.includes('design with this name already exists')) {
      throw new Error(`Duplicate name: ${data.error}`);
    }
    throw new Error(data.error || 'Failed to save design');
  }

  return data;
}

/**
 * Capture current design data
 */
function captureDesignData() {
  const designData = {
    layers: {},
    timestamp: new Date().toISOString(),
  };

  Object.entries(layers).forEach(([layerName, layer]) => {
    designData.layers[layerName] = {
      color: "#" + layer.mesh.material.color.getHexString(),
      material: layer.material,
      decals: layer.decals.map((decal) => {
        const decalData = {
          id: decal.id,
          name: decal.name,
          type: decal.type,
          position: decal.position,
          size: decal.size,
          rotation: decal.rotation,
          opacity: decal.opacity,
          flipX: decal.flipX || false,
          flipY: decal.flipY || false,
          aspectLocked: decal.aspectLocked !== false
        };

        // Save type-specific data needed to recreate textures
        if (decal.type === 'text') {
          // Check if textData exists or create it from direct properties
          if (decal.textData) {
            decalData.textData = decal.textData;
          } else {
            // Create textData from direct properties for backward compatibility
            decalData.textData = {
              text: decal.text || 'Sample Text',
              font: decal.font || 'Roboto',
              color: decal.color || '#000000',
              letterSpacing: decal.letterSpacing || 0,
              borderWidth: decal.borderWidth || 0,
              borderColor: decal.borderColor || '#000000'
            };
          }
        } else if (decal.type === 'image') {
          if (decal.imageUrl) {
            decalData.imageUrl = decal.imageUrl;
          } else {
            debugWarn('Image decal missing imageUrl:', decal);
          }
        } else if (decal.type === 'fade' && decal.fadeData) {
          decalData.fadeData = decal.fadeData;
        }

        return decalData;
      }),
    };
  });

  return designData;
}

/**
 * Open templates browser (placeholder)
 */
function openTemplates() {
  alert(
    "Templates browser coming soon! This will show pre-made design templates you can apply to your product."
  );
}

/**
 * Show clear design confirmation modal
 */
function confirmClearDesign() {
  const modal = new bootstrap.Modal(
    document.getElementById("clearConfirmModal")
  );
  modal.show();
}

/**
 * Clear current design (called from confirmation modal)
 */
function clearDesign() {
  // Close the modal first
  const modal = bootstrap.Modal.getInstance(
    document.getElementById("clearConfirmModal")
  );
  if (modal) {
    modal.hide();
  }

  // Reset all layers to default colors and materials
  Object.values(layers).forEach((layer) => {
    // Reset to initial color
    const meshSettings = layer.meshSettings;
    if (meshSettings.initialColor) {
      layer.mesh.material.color.setHex(parseInt(meshSettings.initialColor, 16));
    } else {
      layer.mesh.material.color.setHex(0xffffff); // Default white
    }

    // Reset material properties
    layer.mesh.material.metalness = 0;
    layer.mesh.material.roughness = 1;
    layer.mesh.material.bumpMap = null;
    layer.mesh.material.needsUpdate = true;

    // Clear decals
    layer.decals = [];
    layer.material = window.phpData.product.initialBumpmap || "none";
  });

  // Reset current selections
  currentDecal = null;

  // Reset design name
  designName = "Untitled Design";
  updateDesignNameDisplay();

  // Update UI
  updateColorControls();
  updateMaterialOptions();
  updateDecalsList();

  debugLog("Design cleared and reset to defaults");
}

/**
 * Open edit design name modal
 */
function editDesignName() {
  // Set current design name in the input
  document.getElementById("design-name-input").value = designName;

  // Show modal
  const modal = new bootstrap.Modal(
    document.getElementById("editDesignNameModal")
  );
  modal.show();

  // Focus on input after modal is shown
  setTimeout(() => {
    document.getElementById("design-name-input").select();
  }, 150);
}

/**
 * Save design name from modal
 */
function saveDesignName() {
  const newName = document.getElementById("design-name-input").value.trim();

  if (newName && newName.length > 0) {
    const previousName = designName;
    designName = newName;
    updateDesignNameDisplay();

    // Close modal
    const modal = bootstrap.Modal.getInstance(
      document.getElementById("editDesignNameModal")
    );
    if (modal) {
      modal.hide();
    }

    debugLog("Design name updated to:", designName);
    
    // If this was triggered from save and name was previously "Untitled Design", continue with save
    if (previousName === 'Untitled Design' && window.pendingSaveAfterNameChange) {
      window.pendingSaveAfterNameChange = false;
      performSaveDesign();
    }
  } else {
    alert("Please enter a valid design name.");
  }
}

/**
 * Update design name display in sidebar
 */
function updateDesignNameDisplay() {
  document.getElementById("design-name-display").textContent = designName;
}

/**
 * Update decal position
 */
function updateDecalPosition(axis, value) {
  if (!currentDecal) return;

  currentDecal.position[axis] = parseFloat(value);
  renderLayer();
}

/**
 * Update decal size
 */
function updateDecalSize(value) {
  if (!currentDecal) return;

  const scale = parseFloat(value);
  // Maintain aspect ratio
  const aspectRatio = currentDecal.size.y / currentDecal.size.x;
  currentDecal.size.x = scale;
  currentDecal.size.y = scale * aspectRatio;
  renderLayer();
}

/**
 * Update decal rotation
 */
function updateDecalRotation(value) {
  if (!currentDecal) return;

  currentDecal.rotation = parseFloat(value);
  renderLayer();
}

/**
 * Update decal opacity
 */
function updateDecalOpacity(value) {
  if (!currentDecal) return;

  currentDecal.opacity = parseFloat(value);
  renderLayer();
}

/**
 * Toggle decal flip
 */
function toggleDecalFlip(axis) {
  if (!currentDecal) return;

  if (axis === "x") {
    currentDecal.flipX = !currentDecal.flipX;
  } else {
    currentDecal.flipY = !currentDecal.flipY;
  }

  renderLayer();
  updateDecalsList(); // Update button states
}

// Export functions to global scope for onclick handlers
window.exitDesigner = exitDesigner;
window.confirmExitDesigner = confirmExitDesigner;
window.saveDesign = saveDesign;
window.saveDesignAndGetId = saveDesignAndGetId;
window.captureDesignData = captureDesignData;
window.captureScreenshots = captureScreenshots;
window.openTemplates = openTemplates;
window.confirmClearDesign = confirmClearDesign;
window.clearDesign = clearDesign;
window.editDesignName = editDesignName;
window.saveDesignName = saveDesignName;
window.updateDesignNameDisplay = updateDesignNameDisplay;
window.takeScreenshot = takeScreenshot;
window.addImageDecal = addImageDecal;
window.addTextDecal = addTextDecal;
window.addFadeDecal = addFadeDecal;
window.deleteDecal = deleteDecal;
window.duplicateDecal = duplicateDecal;
window.duplicateDecalAndStayInEdit = duplicateDecalAndStayInEdit;
window.showDecalLayerMenu = showDecalLayerMenu;
window.moveDecalToLayer = moveDecalToLayer;
window.copyDecalToLayer = copyDecalToLayer;
window.copyDecalToAllLayers = copyDecalToAllLayers;
window.formatLayerName = formatLayerName;
window.rotateView = rotateView;
window.rotateCamera = rotateCamera;
window.zoomCamera = zoomCamera;
window.openTutorials = openTutorials;
window.setCurrentLayer = setCurrentLayer;
/**
 * Image Bank Variables
 */
let imageBankModal = null;
let selectedImageData = null;
let currentCategoryId = null;
let imageUploadSetup = false; // Track if upload handlers are already set up

/**
 * Open image bank modal
 */
// Image bank cache
let imageBankCache = {
  categories: [],
  images: {},
  loadedAt: null,
  isStale: false,
};

/**
 * Refresh image bank cache
 */
function refreshImageBankCache() {
  debugLog("Refreshing image bank cache...");

  // Clear cache
  imageBankCache.categories = [];
  imageBankCache.images = {};
  imageBankCache.isStale = false;

  // Reload categories from API
  const categoriesContainer = document.getElementById("image-categories");
  categoriesContainer.innerHTML =
    '<div class="loading-spinner"><div class="spinner-border spinner-border-sm"></div></div>';

  fetch("/api/images.php?path=categories")
    .then((response) => response.json())
    .then((data) => {
      if (data.categories) {
        imageBankCache.categories = data.categories;
        imageBankCache.loadedAt = Date.now();
        renderCategories(data.categories);

        // Reload current category images
        if (currentCategoryId) {
          loadImages(currentCategoryId);
        }
      }
    })
    .catch((error) => {
      debugError("Failed to refresh image bank cache:", error);
    });
}

function openImageBank() {
  // Initialize modal if not already done
  if (!imageBankModal) {
    imageBankModal = new bootstrap.Modal(
      document.getElementById("imageBankModal")
    );
  }

  // Reset state
  selectedImageData = null;
  currentCategoryId = null;

  // Initialize cache from PHP data if not already done
  if (!imageBankCache.loadedAt && window.phpData && window.phpData.imageBank) {
    imageBankCache.categories = window.phpData.imageBank.categories;
    imageBankCache.images["all"] = window.phpData.imageBank.initialImages;
    imageBankCache.loadedAt = window.phpData.imageBank.loadedAt;
    debugLog("Image bank cache initialized from PHP data");
  }

  // Load categories and images (uses cache)
  loadImageCategories();

  // Show modal
  imageBankModal.show();

  // Set up drag and drop (only once)
  if (!imageUploadSetup) {
    setupImageUpload();
    imageUploadSetup = true;
  }

  // Set up search functionality
  setupImageSearch();

  // Set up delete confirmation
  setupDeleteConfirmation();
}

/**
 * Load image categories for current brand
 */
function loadImageCategories() {
  const categoriesContainer = document.getElementById("image-categories");

  // Check if we have cached categories
  if (imageBankCache.categories.length > 0) {
    // Use cached data
    renderCategories(imageBankCache.categories);
    // Auto-select first category and load its images
    if (currentCategoryId === null) {
      selectCategory("all");
    }
  } else {
    // Show loading and fetch from API as fallback
    categoriesContainer.innerHTML =
      '<div class="loading-spinner"><div class="spinner-border spinner-border-sm"></div></div>';

    fetch("/api/images.php?path=categories")
      .then((response) => response.json())
      .then((data) => {
        if (data.categories) {
          // Cache the categories
          imageBankCache.categories = data.categories;
          renderCategories(data.categories);

          // Load images for the default category
          if (currentCategoryId === null) {
            selectCategory("all");
          }
        } else {
          throw new Error("No categories in response");
        }
      })
      .catch((error) => {
        debugError("Categories API failed, using fallback:", error);
        // Fallback to basic categories
        const mockCategories = [
          { id: "all", name: "All Images", count: 0 },
          { id: 1, name: "My Images", count: 0 },
          { id: 2, name: "Logos", count: 0 },
          { id: 3, name: "Patterns", count: 0 },
          { id: 4, name: "Graphics", count: 0 },
        ];

        imageBankCache.categories = mockCategories;
        renderCategories(mockCategories);

        // Load images for the default category
        if (currentCategoryId === null) {
          selectCategory("all");
        }
      });
  }
}

function renderCategories(categories) {
  const categoriesContainer = document.getElementById("image-categories");
  let categoriesHtml = "";

  categories.forEach((category) => {
    const isActive =
      currentCategoryId === category.id ||
      (currentCategoryId === null && category.id === "all");
    categoriesHtml += `
      <div class="category-item ${
        isActive ? "active" : ""
      }" data-category-id="${category.id}" onclick="selectCategory('${
      category.id
    }')">
        <span>${category.name}</span>
        <span class="category-count">${category.count}</span>
      </div>
    `;
  });

  categoriesContainer.innerHTML = categoriesHtml;
}

/**
 * Select image category
 */
function selectCategory(categoryId) {
  currentCategoryId = categoryId;

  // Update active state
  document.querySelectorAll(".category-item").forEach((item) => {
    item.classList.remove("active");
  });
  document
    .querySelector(`[data-category-id="${categoryId}"]`)
    .classList.add("active");

  // Update category title
  const categoryName = document.querySelector(
    `[data-category-id="${categoryId}"] span`
  ).textContent;
  document.getElementById("category-title").textContent = categoryName;

  // Load images for this category
  loadImages(categoryId);
}

/**
 * Load images for selected category
 */
function loadImages(categoryId) {
  const imageGrid = document.getElementById("image-grid");
  const loadingElement = document.getElementById("image-grid-loading");
  const emptyElement = document.getElementById("image-grid-empty");
  const searchInput = document.getElementById("image-search-input");
  const searchQuery = searchInput.value || "";

  // Check if we have cached images for this category and no search query
  // For guest users, always fetch fresh data to ensure proper user_owned flags
  if (imageBankCache.images[categoryId] && !searchQuery && !window.phpData.isGuest) {
    // Use cached data
    debugLog("Using cached images for category:", categoryId);
    renderImages(imageBankCache.images[categoryId]);
    return;
  }

  // Show loading
  loadingElement.style.display = "flex";
  imageGrid.style.display = "none";
  emptyElement.style.display = "none";

  // Build API URL
  const searchParams = new URLSearchParams({
    path: "images",
    category_id: categoryId,
    search: searchQuery,
    limit: 20,
  });

  // Fetch from API
  fetch(`/api/images.php?${searchParams}`)
    .then((response) => {
      debugLog("Load images response status:", response.status);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.json();
    })
    .then((data) => {
      debugLog("Load images response data:", data);
      loadingElement.style.display = "none";

      // Cache the images if no search query
      if (!searchQuery && data.images) {
        imageBankCache.images[categoryId] = data.images;
      }

      renderImages(data.images || []);
    })
    .catch((error) => {
      debugError("API failed, showing empty state:", error);
      loadingElement.style.display = "none";
      emptyElement.style.display = "block";
    });
}

function renderImages(images) {
  const imageGrid = document.getElementById("image-grid");
  const emptyElement = document.getElementById("image-grid-empty");

  if (images && images.length > 0) {
    let imagesHtml = "";
    images.forEach((image) => {
      // Debug logging for guest users
      if (window.phpData && window.phpData.isGuest) {
        debugLog("Guest image data:", {
          id: image.id,
          name: image.name,
          user_owned: image.user_owned,
          category_id: image.category_id
        });
      }
      
      // Show delete button only for user-owned images
      const deleteButton = image.user_owned
        ? `<button class="btn btn-sm btn-danger image-delete-btn" onclick="deleteImageWithConfirmation('${image.id}', '${image.name}', event)" title="Delete Image">
          <i class="bi bi-trash" aria-hidden="true"></i>
        </button>`
        : "";

      imagesHtml += `
        <div class="image-item" data-image-id="${
          image.id
        }" onclick="selectImageItem('${image.id}')" 
             data-image-url="${image.r2_url}" data-image-name="${image.name}"
             data-image-width="${image.width}" data-image-height="${
        image.height
      }"
             data-is-pattern="${image.is_from_pattern_category || false}">
          <img src="${image.thumbnail_small_url}" alt="${
        image.name
      }" loading="lazy" 
               onerror="this.src='${
                 image.r2_url
               }'; debugError('Failed to load thumbnail for ${
        image.name
      }:', this.src);">
          <div class="image-item-overlay">
            <div class="image-item-name">${image.name}</div>
            <div class="image-item-size">${image.width} × ${image.height}</div>
          </div>
          ${deleteButton}
        </div>
      `;
    });

    imageGrid.innerHTML = imagesHtml;
    imageGrid.style.display = "grid";
    emptyElement.style.display = "none";
  } else {
    imageGrid.style.display = "none";
    emptyElement.style.display = "block";
  }
}

/**
 * Select an image item
 */
function selectImageItem(imageId) {
  // Remove previous selection
  document.querySelectorAll(".image-item").forEach((item) => {
    item.classList.remove("selected");
  });

  // Select current item
  const selectedItem = document.querySelector(`[data-image-id="${imageId}"]`);
  selectedItem.classList.add("selected");

  // Store selected image data
  selectedImageData = {
    id: imageId,
    name: selectedItem.dataset.imageName,
    url: selectedItem.dataset.imageUrl,
    width: parseInt(selectedItem.dataset.imageWidth),
    height: parseInt(selectedItem.dataset.imageHeight),
    isPattern: selectedItem.dataset.isPattern === "true",
  };

  // Enable select button
  document.getElementById("select-image-btn").disabled = false;
}

/**
 * Confirm image selection and add to design
 */
function selectImage() {
  if (!selectedImageData) return;

  // Show loading indicator
  const loadingOverlay = document.getElementById("image-loading-overlay");
  if (loadingOverlay) {
    loadingOverlay.classList.add("show");
  }

  // Check if we're replacing an existing image decal
  if (window.replacingImageDecalId) {
    // Handle replacement
    handleImageDecalReplacement(selectedImageData);
  } else {
    // Create new image decal from selected image
    createImageDecalFromUrl(
      selectedImageData.url,
      selectedImageData.name,
      selectedImageData.isPattern
    );
  }

  // Close modal
  imageBankModal.hide();
}

/**
 * Create image decal from URL
 */
function createImageDecalFromUrl(imageUrl, imageName, isPattern = false) {
  // Check if max decals limit reached
  if (isMaxDecalsReached()) {
    showMaxDecalsDialog(currentLayer.name);
    return;
  }

  // Option 1: Use proxy URL (current working solution)
  let proxyUrl = imageUrl;
  if (imageUrl.includes("filess.model2design.app/")) {
    const imagePath = imageUrl.replace("https://filess.model2design.app/", "");
    proxyUrl = `/api/image-proxy.php?path=${encodeURIComponent(imagePath)}`;
  }

  // Use Three.js TextureLoader for cleaner code
  const loader = new THREE.TextureLoader();

  loader.load(
    proxyUrl, // Use proxy URL to avoid CORS
    function (texture) {
      // Success - texture loaded
      // Apply optimal texture settings
      applyTextureSettings(texture);

      // Determine size based on pattern category
      const size = isPattern ? { x: 1, y: 1 } : { x: 0.3, y: 0.3 };

      const decal = {
        id: generateId(),
        name: imageName || "Image Decal",
        type: "image",
        texture: texture,
        imageUrl: imageUrl,
        position: { x: 0.5, y: 0.5 },
        size: size,
        rotation: 0,
        opacity: 1,
        flipX: false,
        flipY: false,
        aspectLocked: true,
      };

      currentLayer.decals.push(decal);
      setCurrentDecal(decal.id);
      renderLayer();
      updateDecalsList();

      // Hide loading indicator
      const loadingOverlay = document.getElementById("image-loading-overlay");
      if (loadingOverlay) {
        loadingOverlay.classList.remove("show");
      }

      debugLog("Image decal added from image bank:", imageName, imageUrl);
    },
    function (progress) {
      // Optional: progress callback
      debugLog("Loading texture progress:", progress);
    },
    function (error) {
      // Error callback
      debugError(
        "Failed to load texture via proxy:",
        proxyUrl,
        "Original URL:",
        imageUrl,
        error
      );

      // Hide loading indicator on error
      const loadingOverlay = document.getElementById("image-loading-overlay");
      if (loadingOverlay) {
        loadingOverlay.classList.remove("show");
      }

      alert("Failed to load image. Please check the console for details.");
    }
  );
}

/**
 * Delete image with confirmation dialog
 */
function deleteImageWithConfirmation(imageId, imageName, event) {
  // Prevent triggering the parent click event
  event.stopPropagation();

  // Set the image name in the modal
  document.getElementById("delete-image-name").textContent = imageName;

  // Store the image data for deletion
  window.pendingDeleteImage = { id: imageId, name: imageName };

  // Show the Bootstrap modal
  const deleteModal = new bootstrap.Modal(
    document.getElementById("deleteImageModal")
  );
  deleteModal.show();
}

/**
 * Delete an image
 */
function deleteImage(imageId, imageName) {
  // Show immediate delete indicator
  const imageElement = document.querySelector(`[data-image-id="${imageId}"]`);
  if (imageElement) {
    imageElement.classList.add("deleting");
    const deleteBtn = imageElement.querySelector(".image-delete-btn");
    if (deleteBtn) {
      deleteBtn.innerHTML =
        '<div class="spinner-border spinner-border-sm" role="status"></div>';
      deleteBtn.disabled = true;
    }
  }

  const deleteUrl = `/api/images.php?path=image&id=${encodeURIComponent(
    imageId
  )}`;

  fetch(deleteUrl, {
    method: "DELETE",
    headers: {
      "Content-Type": "application/json",
    },
  })
    .then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.json();
    })
    .then((data) => {
      if (data.success) {
        debugLog(`Image "${imageName}" deleted successfully`);

        // Remove the image from the UI with fade effect
        const imageElement = document.querySelector(
          `[data-image-id="${imageId}"]`
        );
        if (imageElement) {
          imageElement.style.opacity = "0";
          imageElement.style.transform = "scale(0.8)";
          imageElement.style.transition =
            "opacity 0.3s ease, transform 0.3s ease";
          setTimeout(() => {
            imageElement.remove();
          }, 300);
        }

        // Refresh image bank cache to update counts and image list
        refreshImageBankCache();

        // Show success message (you can replace this with a toast notification)
        debugLog(`Image "${imageName}" deleted successfully`);

        // Optional: Show a temporary success message in the UI
        showDeleteSuccessMessage(imageName);
      } else {
        throw new Error(data.error || "Failed to delete image");
      }
    })
    .catch((error) => {
      debugError("Error deleting image:", error);

      // Reset delete button state on error
      const imageElement = document.querySelector(
        `[data-image-id="${imageId}"]`
      );
      if (imageElement) {
        imageElement.classList.remove("deleting");
        const deleteBtn = imageElement.querySelector(".image-delete-btn");
        if (deleteBtn) {
          deleteBtn.innerHTML =
            '<i class="bi bi-trash" aria-hidden="true"></i>';
          deleteBtn.disabled = false;
        }
      }

      showDeleteErrorMessage(imageName);
    });
}

/**
 * Show delete success message
 */
function showDeleteSuccessMessage(imageName) {
  // Create a temporary success message
  const message = document.createElement("div");
  message.className =
    "alert alert-success alert-dismissible fade show position-fixed";
  message.style.cssText =
    "top: 20px; right: 20px; z-index: 9999; min-width: 300px;";
  message.innerHTML = `
    <i class="bi bi-check-circle me-2"></i>
    "${imageName}" has been deleted successfully.
    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
  `;

  document.body.appendChild(message);

  // Auto-remove after 3 seconds
  setTimeout(() => {
    if (message.parentNode) {
      message.remove();
    }
  }, 3000);
}

/**
 * Show delete error message
 */
function showDeleteErrorMessage(imageName) {
  // Create a temporary error message
  const message = document.createElement("div");
  message.className =
    "alert alert-danger alert-dismissible fade show position-fixed";
  message.style.cssText =
    "top: 20px; right: 20px; z-index: 9999; min-width: 300px;";
  message.innerHTML = `
    <i class="bi bi-exclamation-circle me-2"></i>
    Failed to delete "${imageName}". Please try again.
    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
  `;

  document.body.appendChild(message);

  // Auto-remove after 5 seconds
  setTimeout(() => {
    if (message.parentNode) {
      message.remove();
    }
  }, 5000);
}

/**
 * Setup delete confirmation modal
 */
function setupDeleteConfirmation() {
  const confirmDeleteBtn = document.getElementById("confirm-delete-btn");
  if (confirmDeleteBtn) {
    confirmDeleteBtn.addEventListener("click", function () {
      if (window.pendingDeleteImage) {
        // Hide the modal
        const deleteModal = bootstrap.Modal.getInstance(
          document.getElementById("deleteImageModal")
        );
        deleteModal.hide();

        // Perform the deletion
        deleteImage(
          window.pendingDeleteImage.id,
          window.pendingDeleteImage.name
        );

        // Clear the pending data
        window.pendingDeleteImage = null;
      }
    });
  }
}

/**
 * Setup image upload functionality
 */
function setupImageUpload() {
  const uploadZone = document.querySelector(".upload-zone");
  const fileInput = document.getElementById("image-upload-input");

  // Handle drag and drop
  uploadZone.addEventListener("dragover", (e) => {
    e.preventDefault();
    uploadZone.classList.add("dragover");
  });

  uploadZone.addEventListener("dragleave", () => {
    uploadZone.classList.remove("dragover");
  });

  uploadZone.addEventListener("drop", (e) => {
    e.preventDefault();
    uploadZone.classList.remove("dragover");
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      // Show immediate upload indicator
      const progressContainer = document.querySelector(".upload-progress");
      const progressBar = progressContainer.querySelector(".progress-bar");
      const progressText = progressContainer.querySelector(".progress-text");

      uploadZone.classList.add("uploading");
      progressContainer.style.display = "block";
      progressBar.style.width = "0%";
      progressText.textContent = "Preparing upload...";

      // Small delay to show immediate feedback, then start upload
      setTimeout(() => {
        handleImageUpload(files);
      }, 100);
    }
  });

  // Handle file input change
  fileInput.addEventListener("change", (e) => {
    if (e.target.files.length > 0) {
      // Show immediate upload indicator
      const uploadZone = document.querySelector(".upload-zone");
      const progressContainer = document.querySelector(".upload-progress");
      const progressBar = progressContainer.querySelector(".progress-bar");
      const progressText = progressContainer.querySelector(".progress-text");

      uploadZone.classList.add("uploading");
      progressContainer.style.display = "block";
      progressBar.style.width = "0%";
      progressText.textContent = "Preparing upload...";

      // Small delay to show immediate feedback, then start upload
      setTimeout(() => {
        handleImageUpload(e.target.files);
      }, 100);
    }
  });
}

/**
 * Handle image upload
 */
function handleImageUpload(files) {
  debugLog("Uploading images:", files.length);

  const uploadZone = document.querySelector(".upload-zone");
  const progressContainer = document.querySelector(".upload-progress");
  const progressBar = progressContainer.querySelector(".progress-bar");
  const progressText = progressContainer.querySelector(".progress-text");

  // Upload state should already be shown by the calling function
  // Just update the progress text to show actual upload starting
  progressText.textContent = `Starting upload of ${files.length} image${
    files.length > 1 ? "s" : ""
  }...`;

  let uploadedCount = 0;
  const totalFiles = files.length;

  // Process files one by one
  Array.from(files).forEach((file, index) => {
    uploadSingleImage(file, index, totalFiles)
      .then((result) => {
        uploadedCount++;
        const progress = (uploadedCount / totalFiles) * 100;
        progressBar.style.width = progress + "%";
        progressText.textContent = `Uploaded ${uploadedCount} of ${totalFiles} images`;

        if (uploadedCount === totalFiles) {
          // All uploads complete
          setTimeout(() => {
            uploadZone.classList.remove("uploading");
            progressContainer.style.display = "none";
            progressBar.style.width = "0%";

            // Refresh image bank cache to show new images
            refreshImageBankCache();
          }, 1000);
        }
      })
      .catch((error) => {
        debugError("Upload failed:", error);
        uploadedCount++;

        if (uploadedCount === totalFiles) {
          uploadZone.classList.remove("uploading");
          progressContainer.style.display = "none";
          alert("Some uploads failed. Please try again.");
        }
      });
  });
}

/**
 * Upload a single image
 */
function uploadSingleImage(file, index, total) {
  return new Promise((resolve, reject) => {
    const formData = new FormData();
    formData.append("image", file);
    formData.append("name", file.name.replace(/\.[^/.]+$/, "")); // Remove extension
    formData.append(
      "category_id",
      currentCategoryId === "all" ? "" : currentCategoryId
    );

    fetch("/api/images.php?path=upload", {
      method: "POST",
      body: formData,
    })
      .then((response) => {
        debugLog("Upload response status:", response.status);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
      })
      .then((data) => {
        debugLog("Upload response data:", data);
        if (data.success) {
          resolve(data);
        } else {
          reject(new Error(data.error || "Upload failed"));
        }
      })
      .catch((error) => {
        debugError("Upload error:", error);
        reject(error);
      });
  });
}

/**
 * Setup image search functionality
 */
function setupImageSearch() {
  const searchInput = document.getElementById("image-search-input");
  let searchTimeout;

  searchInput.addEventListener("input", () => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
      loadImages(currentCategoryId || "all");
    }, 300); // Debounce search by 300ms
  });
}

window.setCurrentLayerColor = setCurrentLayerColor;
window.setCurrentLayerColorFromHex = setCurrentLayerColorFromHex;
window.copyColorToLayer = copyColorToLayer;
window.copyColorToAllLayers = copyColorToAllLayers;
window.openImageBank = openImageBank;
window.selectImage = selectImage;
window.togglePanel = togglePanel;
window.openCartModal = openCartModal;
window.changeModalQuantity = changeModalQuantity;
window.setModalQuantity = setModalQuantity;
window.updateModalTotal = updateModalTotal;
window.confirmAddToCart = confirmAddToCart;
window.updateDecalPosition = updateDecalPosition;
window.updateDecalSize = updateDecalSize;
window.updateDecalRotation = updateDecalRotation;
window.updateDecalOpacity = updateDecalOpacity;
window.toggleDecalFlip = toggleDecalFlip;
window.enterDecalEditMode = enterDecalEditMode;
window.exitDecalEditMode = exitDecalEditMode;

/**
 * Initialize shared text canvas
 */
function initTextCanvas() {
  if (!textCanvas) {
    textCanvas = document.createElement('canvas');
    textCanvasCtx = textCanvas.getContext('2d');
  }
}

/**
 * Show text editor modal
 */
function showTextEditor(decal = null) {
  initTextCanvas();
  
  // Default values
  const defaults = {
    text: 'Sample Text',
    font: 'Roboto',
    color: '#000000',
    letterSpacing: 0,
    borderWidth: 0,
    borderColor: '#000000'
  };
  
  // If editing existing decal, use its values
  if (decal && decal.type === 'text') {
    defaults.text = decal.text || defaults.text;
    defaults.font = decal.font || defaults.font;
    defaults.color = decal.color || defaults.color;
    defaults.letterSpacing = decal.letterSpacing || 0;
    defaults.borderWidth = decal.borderWidth || 0;
    defaults.borderColor = decal.borderColor || '#000000';
  }
  
  // Create modal HTML
  const modalHTML = `
    <div class="modal fade" id="textEditorModal" tabindex="-1">
      <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">
              <i class="bi bi-fonts me-2"></i>
              \${decal ? 'Edit Text' : 'Add Text'}
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body">
            <div class="row">
              <div class="col-md-8">
                <!-- Text Input -->
                <div class="mb-3">
                  <label for="text-input" class="form-label">Text</label>
                  <input type="text" class="form-control" id="text-input" value="\${defaults.text}" 
                         oninput="updateTextPreview()">
                </div>
                
                <div class="row">
                  <!-- Font Selection -->
                  <div class="col-md-12 mb-3">
                    <label for="font-select" class="form-label">Font</label>
                    <select class="form-select" id="font-select" onchange="updateTextPreview()">
                      <!-- Font options will be populated by JavaScript -->
                    </select>
                  </div>
                </div>
                
                <div class="row">
                  <!-- Text Color -->
                  <div class="col-md-6 mb-3">
                    <label for="text-color" class="form-label">Text Color</label>
                    <div class="input-group">
                      <input type="color" class="form-control form-control-color" id="text-color" 
                             value="\${defaults.color}" oninput="updateTextPreview()">
                      <input type="text" class="form-control" value="\${defaults.color}" 
                             oninput="document.getElementById('text-color').value = this.value; updateTextPreview()">
                    </div>
                  </div>
                  
                  <!-- Letter Spacing -->
                  <div class="col-md-6 mb-3">
                    <label for="letter-spacing" class="form-label">Letter Spacing</label>
                    <div class="input-group">
                      <input type="range" class="form-range" id="letter-spacing-range" 
                             min="-20" max="50" value="\${defaults.letterSpacing}" 
                             oninput="document.getElementById('letter-spacing-value').value = this.value; updateTextPreview()">
                      <input type="number" class="form-control" id="letter-spacing-value" 
                             value="\${defaults.letterSpacing}" min="-20" max="50" style="width: 80px;"
                             oninput="document.getElementById('letter-spacing-range').value = this.value; updateTextPreview()">
                    </div>
                  </div>
                </div>
                
                <div class="row">
                  <!-- Border Width -->
                  <div class="col-md-6 mb-3">
                    <label for="border-width" class="form-label">Border Width</label>
                    <div class="input-group">
                      <input type="range" class="form-range" id="border-width-range" 
                             min="0" max="20" value="\${defaults.borderWidth}" 
                             oninput="document.getElementById('border-width-value').value = this.value; updateTextPreview()">
                      <input type="number" class="form-control" id="border-width-value" 
                             value="\${defaults.borderWidth}" min="0" max="20" style="width: 80px;"
                             oninput="document.getElementById('border-width-range').value = this.value; updateTextPreview()">
                    </div>
                  </div>
                  
                  <!-- Border Color -->
                  <div class="col-md-6 mb-3">
                    <label for="border-color" class="form-label">Border Color</label>
                    <div class="input-group">
                      <input type="color" class="form-control form-control-color" id="border-color" 
                             value="\${defaults.borderColor}" oninput="updateTextPreview()">
                      <input type="text" class="form-control" value="\${defaults.borderColor}" 
                             oninput="document.getElementById('border-color').value = this.value; updateTextPreview()">
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Preview -->
              <div class="col-md-4">
                <div class="text-preview-container border rounded p-3 text-center" style="background: #f8f9fa; min-height: 200px;">
                  <label class="form-label">Preview</label>
                  <canvas id="text-preview-canvas" style="max-width: 100%; height: auto;"></canvas>
                </div>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-primary" onclick="confirmTextEdit(\${decal ? "'" + decal.id + "'" : 'null'})">
              <i class="bi bi-check"></i> \${decal ? 'Update Text' : 'Add Text'}
            </button>
          </div>
        </div>
      </div>
    </div>
  `;
  
  // Remove existing modal if any
  $('#textEditorModal').remove();
  
  // Add modal to body
  $('body').append(modalHTML);
  
  // Show modal
  const modal = new bootstrap.Modal(document.getElementById('textEditorModal'));
  modal.show();
  
  // Populate font selector
  setTimeout(() => {
    const fontSelect = document.getElementById('font-select');
    if (fontSelect && window.phpData && window.phpData.fonts) {
      fontSelect.innerHTML = '';
      window.phpData.fonts.forEach(font => {
        const option = document.createElement('option');
        option.value = font;
        option.textContent = font;
        if (font === defaults.font) {
          option.selected = true;
        }
        fontSelect.appendChild(option);
      });
    }
    
    // Initial preview
    updateTextPreview();
  }, 100);
}

/**
 * Update text preview in the editor
 */
function updateTextPreview() {
  const canvas = document.getElementById('text-preview-canvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const text = document.getElementById('text-input').value || 'Sample Text';
  const font = document.getElementById('font-select').value;
  const fontSize = 96; // Default font size since slider is removed
  const color = document.getElementById('text-color').value;
  const letterSpacing = parseInt(document.getElementById('letter-spacing-value').value);
  const borderWidth = parseInt(document.getElementById('border-width-value').value);
  const borderColor = document.getElementById('border-color').value;
  
  // Set canvas size
  const scale = 2;
  canvas.width = 400 * scale;
  canvas.height = 200 * scale;
  canvas.style.width = '100%';
  canvas.style.height = 'auto';
  
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Set font
  ctx.font = `${fontSize * scale}px '${font}'`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Apply letter spacing by drawing each character separately
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  
  if (letterSpacing === 0 && borderWidth === 0) {
    // Simple text without effects
    ctx.fillStyle = color;
    ctx.fillText(text, centerX, centerY);
  } else {
    // Calculate total width with letter spacing
    let totalWidth = 0;
    for (let i = 0; i < text.length; i++) {
      totalWidth += ctx.measureText(text[i]).width;
      if (i < text.length - 1) totalWidth += letterSpacing * scale;
    }
    
    // Draw text with effects
    let currentX = centerX - totalWidth / 2;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const charWidth = ctx.measureText(char).width;
      
      // Draw border if needed
      if (borderWidth > 0) {
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = borderWidth * scale * 2;
        ctx.strokeText(char, currentX + charWidth / 2, centerY);
      }
      
      // Draw fill
      ctx.fillStyle = color;
      ctx.fillText(char, currentX + charWidth / 2, centerY);
      
      currentX += charWidth + (i < text.length - 1 ? letterSpacing * scale : 0);
    }
  }
}

/**
 * Render text to texture
 */
async function renderTextToTexture(text, font, color, letterSpacing, borderWidth, borderColor) {
  initTextCanvas();
  
  debugLog(`📝 Rendering text: "${text}" with font: "${font}"`);
  
  // Check if fonts are preloaded, if not wait for them
  if (!fontsLoaded) {
    debugLog("⏳ Fonts not preloaded yet, waiting...");
    await loadAllFonts();
  }
  
  // Use cached font status for instant checking
  let fontWorking = fontCache.get(font) !== false;
  
  if (fontWorking) {
    debugLog(`⚡ Font "${font}" ready from cache!`);
  } else {
    debugWarn(`❌ Font "${font}" not working or not cached yet, using fallback. Cache status:`, fontCache.get(font));
    // Test the font again in case it loaded after caching
    const freshTest = testFontInCanvas(font);
    if (freshTest) {
      debugLog(`✅ Font "${font}" is actually working now, updating cache`);
      fontCache.set(font, true);
      fontWorking = true;
    }
  }
  
  // Use fixed square canvas size
  const canvasSize = 2048;
  textCanvas.width = canvasSize;
  textCanvas.height = canvasSize;
  
  // Clear canvas
  textCanvasCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
  
  // Calculate available space considering padding and border
  const padding = 100;
  const borderPadding = borderWidth * 4;
  const maxWidth = canvasSize - (padding * 2) - (borderPadding * 2);
  const maxHeight = canvasSize - (padding * 2) - (borderPadding * 2);
  
  // Start with a large font size and work down to find the optimal size
  let optimalFontSize = 10;
  let bestFit = 0;
  
  // Binary search for optimal font size
  let minSize = 10;
  let maxSize = 800;
  
  while (minSize <= maxSize) {
    const testSize = Math.floor((minSize + maxSize) / 2);
    const testFontString = fontWorking ? 
      `${testSize}px "${font}", sans-serif` : 
      `${testSize}px sans-serif`;
    textCanvasCtx.font = testFontString;
    
    let totalWidth = 0;
    if (letterSpacing === 0) {
      totalWidth = textCanvasCtx.measureText(text).width;
    } else {
      // Calculate total width with letter spacing
      for (let i = 0; i < text.length; i++) {
        totalWidth += textCanvasCtx.measureText(text[i]).width;
        if (i < text.length - 1) totalWidth += letterSpacing;
      }
    }
    
    const textHeight = testSize * 1.2; // Approximate height with line height
    
    if (totalWidth <= maxWidth && textHeight <= maxHeight) {
      optimalFontSize = testSize;
      bestFit = Math.min(totalWidth / maxWidth, textHeight / maxHeight);
      minSize = testSize + 1; // Try larger
    } else {
      maxSize = testSize - 1; // Try smaller
    }
  }
  
  // Set up for rendering with the optimal font size
  const actualFontName = fontWorking ? font : 'sans-serif';
  const fontString = fontWorking ? 
    `${optimalFontSize}px "${font}", sans-serif` : 
    `${optimalFontSize}px sans-serif`;
  textCanvasCtx.font = fontString;
  debugLog(`Setting canvas font to: ${fontString} (font working: ${fontWorking})`);
  debugLog(`Using font: ${actualFontName}, optimal size: ${optimalFontSize}px`);
  
  // Verify the font is actually being used
  const actualFont = textCanvasCtx.font;
  debugLog(`Canvas font after setting: ${actualFont}`);
  
  // Test the font with actual text
  const testWidth = textCanvasCtx.measureText(text).width;
  debugLog(`Text "${text}" width with font "${font}": ${testWidth}px`);
  
  textCanvasCtx.textAlign = 'center';
  textCanvasCtx.textBaseline = 'middle';
  
  const centerX = textCanvas.width / 2;
  const centerY = textCanvas.height / 2;
  
  if (letterSpacing === 0 && borderWidth === 0) {
    // Simple text
    textCanvasCtx.fillStyle = color;
    textCanvasCtx.fillText(text, centerX, centerY);
  } else {
    // Text with effects - recalculate total width with optimal font size
    let totalWidth = 0;
    for (let i = 0; i < text.length; i++) {
      totalWidth += textCanvasCtx.measureText(text[i]).width;
      if (i < text.length - 1) totalWidth += letterSpacing;
    }
    
    let currentX = centerX - totalWidth / 2;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const charWidth = textCanvasCtx.measureText(char).width;
      
      if (borderWidth > 0) {
        textCanvasCtx.strokeStyle = borderColor;
        textCanvasCtx.lineWidth = borderWidth * 2;
        textCanvasCtx.strokeText(char, currentX + charWidth / 2, centerY);
      }
      
      textCanvasCtx.fillStyle = color;
      textCanvasCtx.fillText(char, currentX + charWidth / 2, centerY);
      
      currentX += charWidth + (i < text.length - 1 ? letterSpacing : 0);
    }
  }
  
  const texture = new THREE.CanvasTexture(textCanvas);
  texture.flipY = false;
  texture.needsUpdate = true;
  
  return texture;
}

/**
 * Confirm text edit
 */
async function confirmTextEdit(decalId = null) {
  const text = document.getElementById('text-input').value || 'Sample Text';
  const font = document.getElementById('font-select').value;
  const color = document.getElementById('text-color').value;
  const letterSpacing = parseInt(document.getElementById('letter-spacing-value').value);
  const borderWidth = parseInt(document.getElementById('border-width-value').value);
  const borderColor = document.getElementById('border-color').value;
  
  // Create texture
  const texture = await renderTextToTexture(text, font, color, letterSpacing, borderWidth, borderColor);
  
  if (decalId) {
    // Update existing decal
    const decal = currentLayer.decals.find(d => d.id === decalId);
    if (decal) {
      decal.text = text;
      decal.font = font;
      decal.color = color;
      decal.letterSpacing = letterSpacing;
      decal.borderWidth = borderWidth;
      decal.borderColor = borderColor;
      decal.texture = texture;
      decal.name = text;
      
      // Also update textData object for consistent saving/loading
      decal.textData = {
        text: text,
        font: font,
        color: color,
        letterSpacing: letterSpacing,
        borderWidth: borderWidth,
        borderColor: borderColor
      };
      
      renderLayer();
      updateDecalsList();
      
      // If in edit mode, update the display
      if (window.inDecalEditMode) {
        updateTextEditControls();
      }
    }
  } else {
    // Check if max decals limit reached before creating new decal
    if (isMaxDecalsReached()) {
      showMaxDecalsDialog(currentLayer.name);
      // Close modal
      bootstrap.Modal.getInstance(document.getElementById('textEditorModal')).hide();
      return;
    }

    // Create new decal
    const decal = {
      id: generateId(),
      name: text,
      type: 'text',
      text: text,
      font: font,
      color: color,
      letterSpacing: letterSpacing,
      borderWidth: borderWidth,
      borderColor: borderColor,
      texture: texture,
      position: { x: 0.5, y: 0.5 },
      size: { x: 0.4, y: 0.2 },
      rotation: 0,
      opacity: 1,
      flipX: false,
      flipY: false,
      aspectLocked: true
    };
    
    currentLayer.decals.push(decal);
    setCurrentDecal(decal.id);
    renderLayer();
    updateDecalsList();
  }
  
  // Close modal
  bootstrap.Modal.getInstance(document.getElementById('textEditorModal')).hide();
}

/**
 * Update text edit controls in decal edit mode
 */
function updateTextEditControls() {
  if (!currentDecal || currentDecal.type !== 'text') return;
  
  // Update the displayed values if text controls are visible
  const textContent = document.getElementById('text-content-input');
  if (textContent) {
    textContent.value = currentDecal.text;
  }
}

/**
 * Update text property and re-render texture
 */
async function updateTextProperty(property, value) {
  if (!currentDecal || currentDecal.type !== 'text') return;
  
  // Update the property
  currentDecal[property] = value;
  
  // Update the name if text changed
  if (property === 'text') {
    currentDecal.name = value;
  }
  
  // Also update textData object for consistent saving/loading
  if (!currentDecal.textData) {
    currentDecal.textData = {};
  }
  currentDecal.textData[property] = value;
  
  // Update color value display
  if (property === 'color') {
    const colorValue = document.getElementById('text-color-value');
    if (colorValue) colorValue.textContent = value;
  }
  
  // Update border color value display
  if (property === 'borderColor') {
    const borderColorValue = document.getElementById('text-border-color-value');
    if (borderColorValue) borderColorValue.textContent = value;
  }
  
  // Re-render texture with new properties
  const texture = await renderTextToTexture(
    currentDecal.text,
    currentDecal.font,
    currentDecal.color,
    currentDecal.letterSpacing,
    currentDecal.borderWidth,
    currentDecal.borderColor
  );
  
  currentDecal.texture = texture;
  
  // Re-render the layer
  renderLayer();
  updateDecalsList();
}

/**
 * Update fade decal properties and regenerate texture
 */
function updateFadeProperty(property, value) {
  if (!currentDecal || currentDecal.type !== 'fade') return;
  
  // Initialize fadeData if it doesn't exist
  if (!currentDecal.fadeData) {
    currentDecal.fadeData = {
      baseColor: '#000000',
      blendColor: '#ffffff',
      fadeStart: 0.4,
      mixRatio: 0.5,
      direction: 'Vertical'
    };
  }
  
  // Update the property
  currentDecal.fadeData[property] = value;
  
  // Update value displays
  if (property === 'baseColor') {
    const colorValue = document.getElementById('fade-base-color-value');
    if (colorValue) colorValue.textContent = value;
  } else if (property === 'blendColor') {
    const colorValue = document.getElementById('fade-blend-color-value');
    if (colorValue) colorValue.textContent = value;
  } else if (property === 'fadeStart') {
    const startValue = document.getElementById('fade-start-value');
    if (startValue) startValue.textContent = Math.round(value * 100) + '%';
  } else if (property === 'mixRatio') {
    const mixValue = document.getElementById('fade-mix-ratio-value');
    if (mixValue) mixValue.textContent = Math.round(value * 100) + '%';
  }
  
  // Regenerate fade texture with new properties
  const texture = createFadeTexture(currentDecal.fadeData);
  currentDecal.texture = texture;
  
  // Re-render the layer
  renderLayer();
  updateDecalsList();
  
  debugLog('Fade property updated:', property, value);
}

/**
 * Replace image for current image decal
 */
function replaceImageDecal() {
  if (!currentDecal || currentDecal.type !== 'image') return;
  
  debugLog('Opening image bank to replace image for decal:', currentDecal.id);
  
  // Store reference that we're replacing an image decal
  window.replacingImageDecalId = currentDecal.id;
  
  // Open the image bank modal
  openImageBank();
}

/**
 * Handle image selection for replacing an image decal
 */
function handleImageDecalReplacement(imageData) {
  if (!window.replacingImageDecalId || !currentDecal || currentDecal.id !== window.replacingImageDecalId) {
    debugWarn('No image decal replacement in progress');
    return;
  }
  
  debugLog('Replacing image for decal:', window.replacingImageDecalId, 'with:', imageData);
  
  // Update the decal's image URL
  currentDecal.imageUrl = imageData.url;
  currentDecal.name = imageData.name || 'Image';
  
  // Load the new texture
  const textureLoader = new THREE.TextureLoader();
  
  // Handle proxy URL for R2 storage images
  let imageUrl = imageData.url;
  if (imageData.url.includes("filess.model2design.app/")) {
    const imagePath = imageData.url.replace("https://filess.model2design.app/", "");
    imageUrl = `/api/image-proxy.php?path=${encodeURIComponent(imagePath)}`;
    debugLog('Using proxy URL for replacement:', imageUrl);
  }
  
  textureLoader.load(
    imageUrl,
    function(texture) {
      debugLog('New texture loaded for image replacement');
      texture.encoding = THREE.sRGBEncoding;
      texture.flipY = false;
      texture.needsUpdate = true;
      
      // Update decal texture
      currentDecal.texture = texture;
      
      // Update thumbnail in UI if we're still in edit mode
      const thumbnail = document.getElementById('current-image-thumbnail');
      if (thumbnail) {
        thumbnail.src = imageData.url;
      }
      
      // Re-render the layer
      renderLayer();
      updateDecalsList();
      
      // Hide loading overlay
      const loadingOverlay = document.getElementById("image-loading-overlay");
      if (loadingOverlay) {
        loadingOverlay.classList.remove("show");
      }
      
      debugLog('Image decal replacement completed successfully');
    },
    function(progress) {
      debugLog('Loading new image texture:', Math.round(progress.loaded / progress.total * 100) + '%');
    },
    function(error) {
      debugError('Error loading new image texture:', error);
      
      // Hide loading overlay on error too
      const loadingOverlay = document.getElementById("image-loading-overlay");
      if (loadingOverlay) {
        loadingOverlay.classList.remove("show");
      }
      
      alert('Failed to load the selected image. Please try again.');
    }
  );
  
  // Clear the replacement flag
  delete window.replacingImageDecalId;
}

/**
 * Populate font selector in text edit mode
 */
function populateTextFontSelector() {
  const fontDropdown = document.getElementById('text-font-dropdown');
  const fontMenu = document.getElementById('text-font-menu');
  const fontDisplay = document.getElementById('text-font-display');
  
  if (!fontDropdown || !fontMenu || !fontDisplay || !window.phpData || !window.phpData.fonts) return;
  
  fontMenu.innerHTML = '';
  
  // Check if fonts are still loading
  const isLoadingFonts = !fontsLoaded || (currentDecal && currentDecal.isLoadingFont);
  
  if (isLoadingFonts) {
    // Show loading state
    fontDropdown.disabled = true;
    fontDisplay.textContent = '🔄 Loading fonts...';
    fontDisplay.style.fontFamily = 'inherit';
    return;
  }
  
  // Enable dropdown
  fontDropdown.disabled = false;
  
  // Add custom CSS for font options - always recreate to ensure updates
  let fontStyleElement = document.getElementById('font-selector-styles');
  if (fontStyleElement) {
    fontStyleElement.remove();
  }
  fontStyleElement = document.createElement('style');
  fontStyleElement.id = 'font-selector-styles';
  document.head.appendChild(fontStyleElement);
  
  // Build CSS rules for each font
  let fontCSS = '';
  
  window.phpData.fonts.forEach((font, index) => {
    const li = document.createElement('li');
    const button = document.createElement('button');
    button.className = 'dropdown-item py-1';
    button.type = 'button';
    button.textContent = font;
    
    // Add class for styling
    const className = `font-option-${index}`;
    button.classList.add(className);
    
    // Add CSS rule for this font
    fontCSS += `.${className} { font-family: "${font}", sans-serif !important; font-weight: 400; }\n`;
    
    // Handle font selection
    button.addEventListener('click', function() {
      fontDisplay.textContent = font;
      fontDisplay.style.fontFamily = `"${font}", sans-serif`;
      updateTextProperty('font', font);
      // Close dropdown
      fontMenu.style.display = 'none';
    });
    
    li.appendChild(button);
    fontMenu.appendChild(li);
  });
  
  // Apply the CSS
  fontStyleElement.textContent = `
    #text-font-dropdown {
      font-size: 16px;
    }
    #text-font-menu {
      white-space: nowrap !important;
      overflow-x: hidden !important;
    }
    .dropdown-item.py-1 {
      padding: 4px 12px !important;
      font-size: 14px !important;
      line-height: 1.3 !important;
      min-height: 32px !important;
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
    }
    ${fontCSS}
  `;
  
  // Set the current font display
  if (currentDecal && currentDecal.font) {
    fontDisplay.textContent = currentDecal.font;
    fontDisplay.style.fontFamily = `"${currentDecal.font}", sans-serif`;
  } else {
    fontDisplay.textContent = 'Roboto';
    fontDisplay.style.fontFamily = '"Roboto", sans-serif';
  }
  
  // Add dropdown toggle functionality
  fontDropdown.addEventListener('click', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (fontMenu.style.display === 'none' || !fontMenu.style.display) {
      // Position the dropdown menu
      const rect = fontDropdown.getBoundingClientRect();
      fontMenu.style.left = rect.left + 'px';
      fontMenu.style.top = (rect.bottom + 2) + 'px';
      fontMenu.style.width = rect.width + 'px';
      fontMenu.style.display = 'block';
      
      // Add click outside handler
      setTimeout(() => {
        document.addEventListener('click', closeDropdownHandler);
      }, 0);
    } else {
      fontMenu.style.display = 'none';
      document.removeEventListener('click', closeDropdownHandler);
    }
  });
  
  function closeDropdownHandler(e) {
    if (!fontDropdown.contains(e.target) && !fontMenu.contains(e.target)) {
      fontMenu.style.display = 'none';
      document.removeEventListener('click', closeDropdownHandler);
    }
  }
}

// Update font selector loading state
function updateFontSelectorLoadingState() {
  populateTextFontSelector();
}

/**
 * Wrapper functions to properly close dropdown before executing main functions
 */
function closeDropdownAndAddText(event) {
  // Prevent default link behavior
  event.preventDefault();
  
  // Close the dropdown manually
  const dropdown = bootstrap.Dropdown.getInstance(document.getElementById('addDesignBtn'));
  if (dropdown) {
    dropdown.hide();
  }
  
  // Use setTimeout to ensure dropdown closes before showing prompt
  setTimeout(() => {
    addTextDecal();
  }, 100);
}

function closeDropdownAndAddFade(event) {
  // Prevent default link behavior
  event.preventDefault();
  
  // Close the dropdown manually
  const dropdown = bootstrap.Dropdown.getInstance(document.getElementById('addDesignBtn'));
  if (dropdown) {
    dropdown.hide();
  }
  
  // Use setTimeout to ensure dropdown closes before executing
  setTimeout(() => {
    addFadeDecal();
  }, 100);
}

// Export functions
window.updateTextProperty = updateTextProperty;
window.updateFadeProperty = updateFadeProperty;
window.replaceImageDecal = replaceImageDecal;
window.handleImageDecalReplacement = handleImageDecalReplacement;
window.populateTextFontSelector = populateTextFontSelector;
window.closeDropdownAndAddText = closeDropdownAndAddText;
window.closeDropdownAndAddFade = closeDropdownAndAddFade;
