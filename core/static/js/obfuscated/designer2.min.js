/* Obfuscated Designer JavaScript - Thu Aug 21 08:16:21 PM EDT 2025 */

/* Obfuscated Designer JavaScript - Thu Aug 21 07:30:45 PM EDT 2025 */

/**
 * Designer 2 - Compact Topbar Version
 * Full Three.js Designer Implementation with Topbar UI
 */

// Debug logging utility - only logs in development environment
function debugLog(...args) {
  const data = window.phpData || window.designerData;
  if (data && data.environment === 'development') {
    console.log(...args);
  }
}

function debugWarn(...args) {
  const data = window.phpData || window.designerData;
  if (data && data.environment === 'development') {
    console.warn(...args);
  }
}

function debugError(...args) {
  const data = window.phpData || window.designerData;
  if (data && data.environment === 'development') {
    console.error(...args);
  }
}

// Immediate test to see if this file loads
debugLog("🚀 Designer2.js file loaded!");
debugLog("Current time:", new Date().toISOString());

// Global variables
let scene, camera, renderer, controls;
let currentLayer = null;
let currentDecal = null;
let layers = {};
let loaded = false;
let designName = "Untitled Design";
let pmremGenerator;

// Shared canvas for text rendering
let textCanvas = null;
let textCanvasCtx = null;

// Font loading status
let fontsLoaded = false;

// Cart variables
let sizeQuantities = {};

// Three.js loaders
let gltfLoader, textureLoader, rgbeLoader;

// Cache for font loading status
const fontCache = new Map();

// Image Bank Variables
let selectedImage = null;
let currentImageCategory = 'all';

// Generate unique ID for decals
function generateId() {
    return Math.random().toString(36).substring(2, 15);
}

// Initialize text canvas
function initTextCanvas() {
    if (!textCanvas) {
        textCanvas = document.createElement('canvas');
        textCanvasCtx = textCanvas.getContext('2d');
    }
}

// Create a placeholder text texture using system fonts
function createPlaceholderTextTexture(text, font, color) {
    initTextCanvas();
    
    const canvasSize = 2048;
    textCanvas.width = canvasSize;
    textCanvas.height = canvasSize;
    
    textCanvasCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
    
    // Use system font as placeholder
    const placeholderFont = 'Arial, sans-serif';
    const fontSize = 200; // Large placeholder size
    
    textCanvasCtx.font = `${fontSize}px ${placeholderFont}`;
    textCanvasCtx.textAlign = 'center';
    textCanvasCtx.textBaseline = 'middle';
    textCanvasCtx.fillStyle = color;
    
    const centerX = textCanvas.width / 2;
    const centerY = textCanvas.height / 2;
    
    textCanvasCtx.fillText(text, centerX, centerY);
    
    const texture = new THREE.CanvasTexture(textCanvas);
    texture.flipY = false;
    texture.needsUpdate = true;
    
    return texture;
}

// Render text to texture with loaded fonts
async function renderTextToTexture(text, font, color, letterSpacing = 0, borderWidth = 0, borderColor = '#000000') {
    initTextCanvas();
    
    const canvasSize = 2048;
    textCanvas.width = canvasSize;
    textCanvas.height = canvasSize;
    
    textCanvasCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
    
    // Use a large font size for high quality
    const fontSize = 200;
    const fontString = `${fontSize}px "${font}", Arial, sans-serif`;
    
    textCanvasCtx.font = fontString;
    textCanvasCtx.textAlign = 'center';
    textCanvasCtx.textBaseline = 'middle';
    
    const centerX = textCanvas.width / 2;
    const centerY = textCanvas.height / 2;
    
    // Apply letter spacing if specified
    if (letterSpacing > 0) {
        // Manual letter spacing implementation
        const letters = text.split('');
        const totalWidth = textCanvasCtx.measureText(text).width + (letters.length - 1) * letterSpacing;
        let currentX = centerX - totalWidth / 2;
        
        letters.forEach(letter => {
            const letterWidth = textCanvasCtx.measureText(letter).width;
            
            // Draw border if specified
            if (borderWidth > 0) {
                textCanvasCtx.strokeStyle = borderColor;
                textCanvasCtx.lineWidth = borderWidth;
                textCanvasCtx.strokeText(letter, currentX + letterWidth / 2, centerY);
            }
            
            // Draw main text
            textCanvasCtx.fillStyle = color;
            textCanvasCtx.fillText(letter, currentX + letterWidth / 2, centerY);
            
            currentX += letterWidth + letterSpacing;
        });
    } else {
        // Draw border if specified
        if (borderWidth > 0) {
            textCanvasCtx.strokeStyle = borderColor;
            textCanvasCtx.lineWidth = borderWidth;
            textCanvasCtx.strokeText(text, centerX, centerY);
        }
        
        // Draw main text
        textCanvasCtx.fillStyle = color;
        textCanvasCtx.fillText(text, centerX, centerY);
    }
    
    const texture = new THREE.CanvasTexture(textCanvas);
    texture.flipY = false;
    texture.needsUpdate = true;
    
    return texture;
}

// Load all Google Fonts and cache them
async function loadAllFonts() {
    if (!window.designerData || !window.designerData.fonts) return;
    
    debugLog("🔤 Preloading ALL Google Fonts...");
    
    try {
        // Wait for document fonts to be ready
        debugLog("⏳ Waiting for document.fonts.ready...");
        await document.fonts.ready;
        debugLog("✅ document.fonts.ready completed");
        
        // Additional wait for Google Fonts to settle
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Aggressively preload each font with multiple sizes and weights
        debugLog("🚀 Aggressively preloading fonts...");
        const preloadPromises = [];
        
        for (const font of window.designerData.fonts) {
            // Load multiple sizes and weights to cache them
            const sizes = [16, 24, 48, 72, 96, 144, 200];
            const weights = [400, 700];
            
            for (const size of sizes) {
                for (const weight of weights) {
                    preloadPromises.push(
                        document.fonts.load(`${weight} ${size}px "${font}"`).catch(() => {})
                    );
                }
            }
        }
        
        await Promise.all(preloadPromises);
        debugLog("✅ Font preloading completed");
        
        fontsLoaded = true;
    } catch (error) {
        debugError("💥 Font loading failed:", error);
        fontsLoaded = true; // Continue anyway
    }
}

// Initialize the designer
document.addEventListener('DOMContentLoaded', function() {
    debugLog("Designer 2 initializing...");
    debugLog("Window designerData:", window.designerData);

    // Check if we have required data
    if (!window.designerData || !window.designerData.product) {
        debugError("Missing designerData or product!");
        document.getElementById('loading-overlay').innerHTML = '<div class="loading-content"><h5>Error: Missing product data</h5></div>';
        return;
    }

    // Load fonts first
    loadAllFonts();

    // Wait for all Three.js scripts to load
    let attempts = 0;
    function checkThreeJSReady() {
        attempts++;
        debugLog(`Checking Three.js readiness (attempt ${attempts})...`);
        
        debugLog("THREE:", typeof THREE);
        if (typeof THREE !== "undefined") {
            debugLog("GLTFLoader:", typeof THREE.GLTFLoader);
            debugLog("OrbitControls:", typeof THREE.OrbitControls);
            debugLog("RGBELoader:", typeof THREE.RGBELoader);
        }
        
        if (
            typeof THREE !== "undefined" &&
            THREE.GLTFLoader &&
            THREE.OrbitControls &&
            THREE.RGBELoader
        ) {
            debugLog("Three.js ready, initializing...");

            try {
                // Initialize loaders
                gltfLoader = new THREE.GLTFLoader();
                textureLoader = new THREE.TextureLoader();
                rgbeLoader = new THREE.RGBELoader();

                initThreeJS();
                loadProduct(window.designerData.product);
                initUI();
            } catch (error) {
                debugError("Error initializing Three.js:", error);
                document.getElementById('loading-overlay').innerHTML = '<div class="loading-content"><h5>Error initializing 3D engine</h5></div>';
            }
        } else {
            if (attempts > 100) {
                debugError("Three.js failed to load after 100 attempts");
                document.getElementById('loading-overlay').innerHTML = '<div class="loading-content"><h5>Error: Failed to load 3D libraries</h5></div>';
                return;
            }
            debugLog("Waiting for Three.js...");
            setTimeout(checkThreeJSReady, 100);
        }
    }

    checkThreeJSReady();
});

/**
 * Initialize Three.js scene
 */
function initThreeJS() {
    // Create scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8f9fa);

    // Create camera
    camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    camera.position.set(0, 0, 5);

    // Create renderer with enhanced antialiasing
    renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('three-canvas'),
        antialias: true,
        preserveDrawingBuffer: true,
        powerPreference: "high-performance",
        alpha: false,
    });

    // Enhanced antialiasing and quality settings
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = false;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1;

    // Create PMREM generator for environment maps
    pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    // Create controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = false;

    // Load environment map
    loadEnvironmentMap();

    // Handle window resize
    window.addEventListener("resize", onWindowResize);
    onWindowResize();

    // Start render loop
    animate();

    debugLog("Three.js initialized");
}

/**
 * Animation loop
 */
function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
}

/**
 * Handle window resize
 */
function onWindowResize() {
    const container = document.getElementById("canvas-container");
    const width = container.clientWidth;
    const height = container.clientHeight;

    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // Re-fit camera if model is loaded
    if (loaded && scene.children.length > 2) {
        const model = scene.children.find(
            (child) => child.type === "Group" || child.type === "Object3D"
        );
        if (model) {
            fitCameraToModel(model);
        }
    }
}

/**
 * Load environment map for better lighting and reflections
 */
function loadEnvironmentMap() {
    rgbeLoader.load(
        "/static/neutral.hdr",
        function (texture) {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            scene.environment = envMap;
            texture.dispose();
            pmremGenerator.dispose();
        },
        function (progress) {
            debugLog("Loading environment map...", progress);
        },
        function (error) {
            debugError("Error loading environment map:", error);
        }
    );
}

/**
 * Load a product
 */
function loadProduct(product) {
    debugLog("Loading product:", product);

    if (!product) {
        debugError("No product provided");
        document.getElementById('loading-overlay').innerHTML = '<div class="loading-content"><h5>Error: No product data</h5></div>';
        return;
    }

    if (!product.model_path) {
        debugError("No model path in product data");
        document.getElementById('loading-overlay').innerHTML = '<div class="loading-content"><h5>Error: No 3D model path</h5></div>';
        return;
    }

    // Clear existing scene objects
    clearScene();

    // Load the 3D model
    const modelPath = product.model_path;
    debugLog("Loading model from:", modelPath);

    gltfLoader.load(
        modelPath,
        function (gltf) {
            debugLog("Model loaded successfully:", gltf);

            const model = gltf.scene;
            scene.add(model);

            // Initialize layers from the model
            initializeLayers(model);

            // Hide loading overlay
            document.getElementById('loading-overlay').style.display = 'none';
            loaded = true;

            // Update UI
            populateLayerTabs();
            updateColorControls();
            updateMaterialOptions();

            // Set initial layer from product data
            if (window.designerData.product && window.designerData.product.initial_layer) {
                const initialLayer = window.designerData.product.initial_layer;
                debugLog("Setting initial layer to:", initialLayer);
                
                // Find the layer tab and click it
                const layerTabs = document.querySelectorAll('.layer-tab');
                layerTabs.forEach(tab => {
                    if (tab.dataset.layer === initialLayer) {
                        tab.click();
                        debugLog("Initial layer set to:", initialLayer);
                    }
                });
            }

            // Auto-fit camera
            fitCameraToModel(model);
            
            debugLog("Designer initialization complete!");
        },
        function (progress) {
            debugLog("Loading progress:", progress);
            if (progress.total > 0) {
                const percent = Math.round((progress.loaded / progress.total) * 100);
                document.querySelector('#loading-overlay .loading-content h5').textContent = `Loading model... ${percent}%`;
            }
        },
        function (error) {
            debugError("Model loading error:", error);
            document.getElementById('loading-overlay').innerHTML = '<div class="loading-content"><h5>Error loading 3D model</h5><p>' + error.message + '</p></div>';
        }
    );
}

/**
 * Clear the scene
 */
function clearScene() {
    const objectsToRemove = [];

    scene.traverse((child) => {
        if (child.isMesh || child.isLight) {
            objectsToRemove.push(child);
        }
    });

    objectsToRemove.forEach((obj) => {
        scene.remove(obj);

        if (obj.geometry) {
            obj.geometry.dispose();
        }

        if (obj.material) {
            if (obj.material.map) obj.material.map.dispose();
            if (obj.material.bumpMap) obj.material.bumpMap.dispose();
            if (obj.material.normalMap) obj.material.normalMap.dispose();
            obj.material.dispose();
        }
    });

    layers = {};
    currentLayer = null;
    currentDecal = null;
}

/**
 * Initialize layers from the 3D model
 */
function initializeLayers(model) {
    layers = {};

    model.traverse((child) => {
        if (child.isMesh && child.material && !child.name.includes("polySurface")) {
            debugLog("Found mesh:", child.name);

            child.material = child.material.clone();
            child.material.metalness = 0;
            child.material.roughness = 1;

            if (child.material.map) {
                child.material.map.encoding = THREE.sRGBEncoding;
            }

            const meshSettings = window.designerData.product.mesh_settings && 
                                window.designerData.product.mesh_settings[child.name]
                ? window.designerData.product.mesh_settings[child.name]
                : { canSelect: true, canAddImages: true, canChangeColor: true };

            if (meshSettings.initialColor) {
                child.material.color.setHex(parseInt(meshSettings.initialColor, 16));
            }

            layers[child.name] = {
                name: child.name,
                mesh: child,
                decals: [],
                material: window.designerData.product.initial_bumpmap || "none",
                meshSettings: meshSettings,
                minX: meshSettings.minX || 0,
                maxX: meshSettings.maxX || 1,
                minY: meshSettings.minY || 0,
                maxY: meshSettings.maxY || 1,
                roughness: 1,
                metalness: 0,
                color: '#ffffff'
            };
        }
    });

    // Set initial layer
    let initialLayer = window.designerData.product.initial_layer;

    if (!initialLayer || !layers[initialLayer] || !layers[initialLayer].meshSettings.canSelect) {
        initialLayer = Object.keys(layers).find(
            (layerName) => layers[layerName].meshSettings && layers[layerName].meshSettings.canSelect
        );
    }

    if (initialLayer && layers[initialLayer]) {
        setCurrentLayer(initialLayer);
    }

    debugLog("Layers initialized:", Object.keys(layers));
}

/**
 * Fit camera to model
 */
function fitCameraToModel(model) {
    const box = new THREE.Box3().setFromObject(model);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());

    const container = document.getElementById("canvas-container");
    const aspect = container.clientWidth / container.clientHeight;

    const horizontalFOV = 2 * Math.atan(Math.tan((camera.fov * Math.PI) / 360) * aspect);
    const verticalFOV = (camera.fov * Math.PI) / 180;

    const horizontalDistance = size.x / (2 * Math.tan(horizontalFOV / 2));
    const verticalDistance = size.y / (2 * Math.tan(verticalFOV / 2));
    const depthDistance = size.z * 0.5;

    const distance = Math.max(horizontalDistance, verticalDistance, depthDistance) * 1.5;

    camera.position.set(center.x, center.y, center.z + distance);
    controls.target.copy(center);
    controls.update();

    controls.minDistance = distance * 0.5;
    controls.maxDistance = distance * 3;
}

/**
 * Set current layer
 */
function setCurrentLayer(layerName) {
    if (!layers[layerName]) return;

    if (!layers[layerName].meshSettings || !layers[layerName].meshSettings.canSelect) {
        debugWarn("Layer", layerName, "is not selectable");
        return;
    }

    currentLayer = layers[layerName];
    debugLog("Current layer set to:", layerName);

    // Update UI
    updateLayerButtons();
    updateLayerContent();
    updateColorPicker();
    renderLayer();
}

/**
 * UI Functions
 */
function initUI() {
    // Initialize color picker
    const colorPicker = document.getElementById('layer-color-input');
    const colorTrigger = document.getElementById('color-picker-trigger');
    
    colorTrigger.addEventListener('click', () => {
        colorPicker.click();
    });
    
    colorPicker.addEventListener('change', (e) => {
        const color = e.target.value;
        if (currentLayer) {
            currentLayer.color = color;
            currentLayer.mesh.material.color.set(color);
            colorTrigger.style.backgroundColor = color;
        }
    });
    
    // Initialize decal controls
    initializeDecalControls();
    
    // Initialize layer dropdown
    initializeLayerDropdown();
    
    // Initialize add design dropdown
    initializeAddDesignDropdown();
    
    // Initialize layer materials dropdown
    initializeLayerMaterialsDropdown();
    
    // Initialize modals
    initializeModals();
    
    // Initialize cart
    updateCartBadge();
}

function populateLayerTabs() {
    // Update layer dropdown to show all selectable layers
    const selectableLayers = Object.keys(layers).filter(
        layerName => layers[layerName].meshSettings && layers[layerName].meshSettings.canSelect
    );
    
    populateLayerDropdown(selectableLayers);
    debugLog("Selectable layers:", selectableLayers);
}

function populateLayerDropdown(selectableLayers) {
    const dropdownMenu = document.getElementById('layer-dropdown-menu');
    if (!dropdownMenu) return;
    
    // Clear existing options
    dropdownMenu.innerHTML = '';
    
    // Add layer icons mapping
    const layerIcons = {
        'Front': 'bi-square',
        'Back': 'bi-square-fill',
        'Hood': 'bi-cone-striped',
        'Pockets': 'bi-bag',
        'Left_Sleeve': 'bi-arrows-angle-expand',
        'Right_Sleeve': 'bi-arrows-angle-contract',
        'Strings': 'bi-grip-horizontal',
        'Zip': 'bi-grip-vertical',
        'Zip_Cloth': 'bi-grip-vertical'
    };
    
    // Create options for each selectable layer
    selectableLayers.forEach(layerName => {
        const option = document.createElement('div');
        option.className = 'layer-option';
        option.dataset.layer = layerName;
        
        const iconClass = layerIcons[layerName] || 'bi-square';
        const displayName = layerName.replace('_', ' ');
        
        option.innerHTML = `
            <div class="layer-icon">
                <i class="${iconClass}"></i>
            </div>
            <span>${displayName}</span>
        `;
        
        option.addEventListener('click', () => {
            selectLayerFromDropdown(layerName);
        });
        
        dropdownMenu.appendChild(option);
    });
}

function initializeLayerDropdown() {
    const trigger = document.getElementById('layer-dropdown-trigger');
    const menu = document.getElementById('layer-dropdown-menu');
    
    if (!trigger || !menu) return;
    
    // Toggle dropdown on trigger click
    trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        trigger.classList.toggle('active');
        menu.classList.toggle('show');
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!trigger.contains(e.target) && !menu.contains(e.target)) {
            trigger.classList.remove('active');
            menu.classList.remove('show');
        }
    });
}

function initializeAddDesignDropdown() {
    const trigger = document.getElementById('add-design-trigger');
    const menu = document.getElementById('add-design-menu');
    
    if (!trigger || !menu) return;
    
    // Toggle dropdown on trigger click
    trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        trigger.classList.toggle('active');
        menu.classList.toggle('show');
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!trigger.contains(e.target) && !menu.contains(e.target)) {
            trigger.classList.remove('active');
            menu.classList.remove('show');
        }
    });
    
    // Close dropdown when selecting an option
    menu.addEventListener('click', () => {
        trigger.classList.remove('active');
        menu.classList.remove('show');
    });
}

function selectLayerFromDropdown(layerName) {
    switchLayer(layerName);
    
    // Update dropdown trigger text
    const currentLayerName = document.getElementById('current-layer-name');
    if (currentLayerName) {
        currentLayerName.textContent = layerName.replace('_', ' ');
    }
    
    // Update active state in dropdown
    document.querySelectorAll('.layer-option').forEach(option => {
        option.classList.remove('active');
    });
    
    const activeOption = document.querySelector(`[data-layer="${layerName}"]`);
    if (activeOption) {
        activeOption.classList.add('active');
    }
    
    // Close dropdown
    const trigger = document.getElementById('layer-dropdown-trigger');
    const menu = document.getElementById('layer-dropdown-menu');
    if (trigger && menu) {
        trigger.classList.remove('active');
        menu.classList.remove('show');
    }
}

function updateLayerButtons() {
    // Legacy function - now handled by dropdown
    debugLog("Layer buttons updated via dropdown");
}

function updateLayerContent() {
    if (!currentLayer) return;
    
    updateDecalList();
}

function updateColorPicker() {
    const colorTrigger = document.getElementById('color-picker-trigger');
    const colorInput = document.getElementById('layer-color-input');
    
    if (currentLayer) {
        colorTrigger.style.backgroundColor = currentLayer.color;
        colorInput.value = currentLayer.color;
    }
}

function updateDecalList() {
    const decalContainer = document.getElementById('layer-decals');
    decalContainer.innerHTML = '';
    
    if (!currentLayer) return;
    
    currentLayer.decals.forEach((decal, index) => {
        const decalItem = document.createElement('div');
        decalItem.className = 'decal-item';
        decalItem.onclick = (e) => selectDecal(index, e);
        
        if (decal.type === 'image') {
            decalItem.innerHTML = `
                <img src="${decal.thumbnail}" class="decal-thumbnail" alt="">
                <span>${decal.name}</span>
            `;
        } else {
            decalItem.innerHTML = `
                <i class="bi bi-fonts"></i>
                <span>${decal.text}</span>
            `;
        }
        
        decalContainer.appendChild(decalItem);
    });
}

function selectDecal(index, event) {
    if (!currentLayer) return;
    
    currentDecal = currentLayer.decals[index];
    
    // Update active state
    document.querySelectorAll('.decal-item').forEach((item, i) => {
        item.classList.toggle('active', i === index);
    });
    
    // Show popover
    showDecalControls(event.currentTarget);
    updateControlValues();
}

function showDecalControls(target) {
    const popover = document.getElementById('decal-controls-popover');
    const rect = target.getBoundingClientRect();
    
    popover.style.top = (rect.bottom + 10) + 'px';
    popover.style.left = rect.left + 'px';
    popover.classList.add('show');
    
    // Close on click outside
    setTimeout(() => {
        document.addEventListener('click', hideDecalControls);
    }, 100);
}

function hideDecalControls(e) {
    const popover = document.getElementById('decal-controls-popover');
    if (!popover.contains(e.target) && !e.target.closest('.decal-item')) {
        popover.classList.remove('show');
        document.removeEventListener('click', hideDecalControls);
    }
}

function updateControlValues() {
    if (!currentDecal) return;
    
    document.getElementById('decal-pos-x').value = currentDecal.position?.x || 0;
    document.getElementById('decal-pos-x-value').textContent = (currentDecal.position?.x || 0).toFixed(2);
    
    document.getElementById('decal-pos-y').value = currentDecal.position?.y || 0;
    document.getElementById('decal-pos-y-value').textContent = (currentDecal.position?.y || 0).toFixed(2);
    
    document.getElementById('decal-size').value = currentDecal.size?.x || 0.3;
    document.getElementById('decal-size-value').textContent = (currentDecal.size?.x || 0.3).toFixed(2);
    
    document.getElementById('decal-rotation').value = currentDecal.rotation || 0;
    document.getElementById('decal-rotation-value').textContent = (currentDecal.rotation || 0) + '°';
}

function initializeDecalControls() {
    const controls = ['pos-x', 'pos-y', 'size', 'rotation'];
    
    controls.forEach(control => {
        const slider = document.getElementById(`decal-${control}`);
        const value = document.getElementById(`decal-${control}-value`);
        
        slider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            if (control === 'rotation') {
                value.textContent = `${val}°`;
            } else {
                value.textContent = val.toFixed(2);
            }
            
            if (currentDecal) {
                updateDecalProperty(control, val);
            }
        });
    });
}

function updateDecalProperty(property, value) {
    if (!currentDecal) return;
    
    if (!currentDecal.position) currentDecal.position = { x: 0, y: 0 };
    
    switch(property) {
        case 'pos-x':
            currentDecal.position.x = value;
            break;
        case 'pos-y':
            currentDecal.position.y = value;
            break;
        case 'size':
            // Update both x and y size for uniform scaling
            if (!currentDecal.size) currentDecal.size = { x: 0.3, y: 0.3 };
            const aspectRatio = currentDecal.aspectLocked && currentDecal.size.y && currentDecal.size.x 
                ? currentDecal.size.y / currentDecal.size.x 
                : 1;
            currentDecal.size.x = value;
            currentDecal.size.y = value * aspectRatio;
            break;
        case 'rotation':
            currentDecal.rotation = value;
            break;
    }
    
    renderLayer();
}

function renderLayer() {
    // Re-render the current layer with all decals
    // This would typically update textures and re-apply to the mesh
    debugLog("Rendering layer:", currentLayer?.name);
}

function updateColorControls() {
    updateColorPicker();
}

function updateMaterialOptions() {
    updateMaterialGrid();
}

/**
 * Modal Functions
 */
function initializeModals() {
    updateMaterialGrid();
    updateImageBank();
    initializeFontPreview();
    loadCart();
}

function initializeFontPreview() {
    const textInput = document.getElementById('text-input');
    const fontSelect = document.getElementById('font-select');
    const fontPreview = document.getElementById('font-preview');
    
    function updateFontPreview() {
        const text = textInput.value || 'Preview text';
        const font = fontSelect.value;
        fontPreview.style.fontFamily = `"${font}", Arial, sans-serif`;
        fontPreview.textContent = text;
    }
    
    textInput.addEventListener('input', updateFontPreview);
    fontSelect.addEventListener('change', updateFontPreview);
    updateFontPreview();
}

function updateMaterialGrid() {
    const grid = document.getElementById('material-grid');
    grid.innerHTML = '';
    
    if (!window.designerData.product.material_options) return;
    
    window.designerData.product.material_options.forEach((material, index) => {
        const item = document.createElement('div');
        item.className = 'material-item';
        if (index === 0) item.classList.add('active');
        
        item.innerHTML = `
            <img src="${material.thumbnail}" alt="${material.name}">
            <div class="material-name">${material.name}</div>
        `;
        
        item.onclick = () => selectMaterial(material, item);
        grid.appendChild(item);
    });
}

function selectMaterial(material, element) {
    document.querySelectorAll('.material-item').forEach(item => {
        item.classList.remove('active');
    });
    element.classList.add('active');
    
    // Update all layer materials
    Object.values(layers).forEach(layer => {
        updateLayerMaterial(layer, material);
    });
    
    bootstrap.Modal.getInstance(document.getElementById('materialModal')).hide();
}

function updateLayerMaterial(layer, material) {
    if (!layer.mesh) return;
    
    const mesh = layer.mesh;
    
    // Update material properties
    mesh.material.metalness = material.metalness || 0;
    mesh.material.roughness = material.roughness || 0.5;
    
    if (material.map) {
        textureLoader.load(material.map, (texture) => {
            mesh.material.map = texture;
            mesh.material.needsUpdate = true;
        });
    }
    
    if (material.bumpMap) {
        textureLoader.load(material.bumpMap, (texture) => {
            mesh.material.bumpMap = texture;
            mesh.material.needsUpdate = true;
        });
    }
}

/**
 * Image Bank Functions
 */
function updateImageBank() {
    updateCategoryList();
    updateImageGrid(window.designerData.imageBank.initialImages);
}

function updateCategoryList() {
    const categoryList = document.getElementById('category-list');
    categoryList.innerHTML = '';
    
    window.designerData.imageBank.categories.forEach(category => {
        const item = document.createElement('div');
        item.className = 'category-item';
        if (category.id === 'all') item.classList.add('active');
        
        item.innerHTML = `
            <span>${category.name}</span>
            <span style="color: #666;">${category.count}</span>
        `;
        
        item.onclick = () => selectCategory(category, item);
        categoryList.appendChild(item);
    });
}

function selectCategory(category, element) {
    document.querySelectorAll('.category-item').forEach(item => {
        item.classList.remove('active');
    });
    element.classList.add('active');
    
    document.getElementById('category-title').textContent = category.name;
    currentImageCategory = category.id;
    
    // In production, you'd fetch images for this category
    loadCategoryImages(category.id);
}

function loadCategoryImages(categoryId) {
    // For now, show all images
    updateImageGrid(window.designerData.imageBank.initialImages);
}

function updateImageGrid(images) {
    const grid = document.getElementById('image-grid');
    grid.innerHTML = '';
    
    images.forEach(image => {
        const item = document.createElement('div');
        item.className = 'image-item';
        
        item.innerHTML = `
            <img src="${image.thumbnail_small_url}" alt="${image.name}" 
                 onerror="this.src='${image.r2_url}'; debugError('Failed to load thumbnail for ${image.name}:', this.src);">
        `;
        
        item.onclick = () => selectImage(image, item);
        grid.appendChild(item);
    });
}

function selectImage(image, element) {
    document.querySelectorAll('.image-item').forEach(item => {
        item.classList.remove('selected');
    });
    element.classList.add('selected');
    
    selectedImage = image;
}

/**
 * Check if current layer has reached the maximum number of decals (14)
 */
function isMaxDecalsReached() {
  if (!currentLayer || !currentLayer.decals) {
    return false;
  }
  return currentLayer.decals.length >= 14;
}

/**
 * Show max decals dialog
 */
function showMaxDecalsDialog(layerName) {
  alert(`The ${layerName} layer has reached the maximum limit of 14 decals. Please delete some decals before adding new ones.`);
}

/**
 * Action Functions
 */
function addTextToCanvas() {
    const text = document.getElementById('text-input').value;
    const font = document.getElementById('font-select').value;
    const color = document.getElementById('text-color').value;
    
    if (!text || !currentLayer) return;
    
    // Check if max decals limit reached
    if (isMaxDecalsReached()) {
        showMaxDecalsDialog(currentLayer.name);
        bootstrap.Modal.getInstance(document.getElementById('textModal')).hide();
        return;
    }
    
    // Create text texture using the same method as original designer
    const placeholderTexture = createPlaceholderTextTexture(text, font, color);
    
    const decal = {
        id: generateId(),
        name: text,
        type: 'text',
        text: text,
        font: font,
        color: color,
        letterSpacing: 0,
        borderWidth: 0,
        borderColor: '#000000',
        texture: placeholderTexture,
        position: { x: 0.5, y: 0.5 },
        size: { x: 0.4, y: 0.2 },
        rotation: 0,
        opacity: 1,
        flipX: false,
        flipY: false,
        aspectLocked: true
    };
    
    currentLayer.decals.push(decal);
    
    // Render using shader
    renderLayer();
    updateDecalList();
    
    // Update texture in background when fonts are ready
    updateTextDecalWhenFontsReady(decal);
    
    bootstrap.Modal.getInstance(document.getElementById('textModal')).hide();
    
    // Clear form
    document.getElementById('text-input').value = '';
}

function createTextMesh(decal) {
    const texture = createPlaceholderTextTexture(decal.text, decal.font, decal.color);
    
    const geometry = new THREE.PlaneGeometry(2, 0.5);
    const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: 0.9
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(decal.position.x, decal.position.y, 0.01);
    
    decal.mesh = mesh;
    scene.add(mesh);
    
    // Try to load proper font if available
    if (fontsLoaded) {
        renderTextToTexture(decal.text, decal.font, decal.color).then(properTexture => {
            mesh.material.map = properTexture;
            mesh.material.needsUpdate = true;
        });
    }
}

function addSelectedImageToCanvas() {
    if (!selectedImage || !currentLayer) return;
    
    // Check if max decals limit reached
    if (isMaxDecalsReached()) {
        showMaxDecalsDialog(currentLayer.name);
        bootstrap.Modal.getInstance(document.getElementById('imageBankModal')).hide();
        return;
    }
    
    // Use proxy URL to avoid CORS issues
    let imageUrl = selectedImage.r2_url;
    if (imageUrl.includes("filess.model2design.app/")) {
        const imagePath = imageUrl.replace("https://filess.model2design.app/", "");
        imageUrl = `/api/image-proxy.php?path=${encodeURIComponent(imagePath)}`;
    }
    
    // Load texture and create decal
    textureLoader.load(imageUrl, (texture) => {
        // Set texture properties for proper shader rendering
        texture.flipY = false;
        texture.needsUpdate = true;
        
        // Determine size based on image type
        const size = { x: 0.3, y: 0.3 };
        
        const decal = {
            id: generateId(),
            name: selectedImage.name || "Image Decal",
            type: 'image',
            texture: texture,
            imageUrl: selectedImage.r2_url,
            position: { x: 0.5, y: 0.5 },
            size: size,
            rotation: 0,
            opacity: 1,
            flipX: false,
            flipY: false,
            aspectLocked: true
        };
        
        currentLayer.decals.push(decal);
        
        // Render using shader
        renderLayer();
        updateDecalList();
    }, 
    undefined, // onProgress
    (error) => {
        debugError("Failed to load image texture:", error);
        alert("Failed to load image. Please try again.");
    });
    
    bootstrap.Modal.getInstance(document.getElementById('imageBankModal')).hide();
}

/**
 * Update text decal when fonts are ready (async)
 */
async function updateTextDecalWhenFontsReady(decal) {
    try {
        // Wait for font to be available
        if (!fontsLoaded) {
            await loadAllFonts();
        }
        
        // Create proper texture with loaded font
        const properTexture = await renderTextToTexture(
            decal.text,
            decal.font,
            decal.color,
            decal.letterSpacing,
            decal.borderWidth,
            decal.borderColor
        );
        
        // Update the decal
        decal.texture = properTexture;
        decal.isLoadingFont = false;
        
        // Re-render the layer
        renderLayer();
        
        debugLog(`✅ Font loaded for decal: ${decal.name}`);
    } catch (error) {
        debugError(`❌ Failed to load font for decal: ${decal.name}`, error);
        decal.isLoadingFont = false;
    }
}

/**
 * Generate switch cases for shader
 */
function generateSwitchCases(numDecals) {
    let switchCases = "";
    for (let i = 0; i < numDecals; i++) {
        switchCases += `
            case ${i}:
                texColor = texture2D(decalImages[${i}], uv);
                break;
        `;
    }
    return switchCases;
}

/**
 * Render layer with decals using shader-based approach
 */
function renderLayer() {
    if (!currentLayer) return;

    const mesh = currentLayer.mesh;
    const decals = currentLayer.decals;

    debugLog("Rendering layer with", decals.length, "decals using shader");

    // If no decals, reset material to default
    if (decals.length === 0) {
        mesh.material.onBeforeCompile = () => {};
        mesh.material.needsUpdate = true;
        return;
    }

    // Ensure Shader is not cached
    mesh.material.customProgramCacheKey = () =>
        Math.random().toString(36).substring(2, 15);

    // Hook Shader
    mesh.material.onBeforeCompile = (shader) => {
        // Set Uniforms
        shader.uniforms.decalImages = { value: decals.map((d) => d.texture) };
        shader.uniforms.decalPositions = {
            value: decals.map((d) => new THREE.Vector2(d.position.x, d.position.y)),
        };
        shader.uniforms.decalRotations = {
            value: decals.map((d) => (d.rotation * Math.PI) / 180),
        };
        shader.uniforms.decalFlipXs = { value: decals.map((d) => d.flipX) };
        shader.uniforms.decalFlipYs = { value: decals.map((d) => d.flipY) };
        shader.uniforms.decalOpacities = { value: decals.map((d) => d.opacity) };
        shader.uniforms.decalSizes = {
            value: decals.map((d) => {
                if (d.aspectLocked && d.texture.image) {
                    return new THREE.Vector2(
                        d.size.x,
                        d.size.x * (d.texture.image.height / d.texture.image.width) // Maintain aspect ratio of image
                    );
                } else {
                    return new THREE.Vector2(d.size.x, d.size.y);
                }
            }),
        };
        shader.uniforms.minX = { value: parseFloat(currentLayer.meshSettings.minX) };
        shader.uniforms.maxX = { value: parseFloat(currentLayer.meshSettings.maxX) };
        shader.uniforms.minY = { value: parseFloat(currentLayer.meshSettings.minY) };
        shader.uniforms.maxY = { value: parseFloat(currentLayer.meshSettings.maxY) };

        // Adjust Vertex Shader
        shader.vertexShader = `
        ${shader.vertexShader.replace("void main", "void originalMain")}
        varying vec2 vDecalUv;
        void main() {
            vDecalUv = uv;
            originalMain();
        }
        `;

        // Define uniforms/vars in global scope
        shader.fragmentShader = shader.fragmentShader.replace(
            "void main()",
            `
            varying vec2 vDecalUv;
            #define MAX_DECALS ${decals.length}
            #if MAX_DECALS > 0
                uniform sampler2D decalImages[MAX_DECALS];
                uniform vec2 decalPositions[MAX_DECALS];
                uniform vec2 decalSizes[MAX_DECALS];
                uniform float decalRotations[MAX_DECALS];
                uniform bool decalFlipXs[MAX_DECALS];
                uniform bool decalFlipYs[MAX_DECALS];
                uniform float decalOpacities[MAX_DECALS];
            #endif
            uniform float minX;
            uniform float maxX;
            uniform float minY;
            uniform float maxY;
            void main()
            `
        );

        // Replace normal texture mapping with custom one
        shader.fragmentShader = shader.fragmentShader.replace(
            "#include <map_fragment>",
            `
            #if MAX_DECALS > 0
                for (int i = 0; i < MAX_DECALS; i++) {
                    vec2 originalUV = vDecalUv;

                    vec2 rotatedUV = vDecalUv - decalPositions[i]; // Translate to origin
                    float c = cos(decalRotations[i]);
                    float s = sin(decalRotations[i]);
                    rotatedUV = vec2(
                        rotatedUV.x * c - rotatedUV.y * s,
                        rotatedUV.x * s + rotatedUV.y * c
                    );
                    rotatedUV += decalPositions[i]; // Translate back to original position

                    vec2 uv = (rotatedUV - decalPositions[i]) / decalSizes[i] + 0.5;
                    
                    if (decalFlipXs[i]) {
                      uv.x = 1.0 - uv.x;
                    }
                    if (decalFlipYs[i]) {
                      uv.y = 1.0 - uv.y;
                    }

                    vec4 texColor = vec4(0.0);
                    switch(i) {
                      ${generateSwitchCases(decals.length)}
                    }
                    if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0 && originalUV.x >= minX && originalUV.x <= maxX && originalUV.y >= minY && originalUV.y <= maxY && gl_FrontFacing) {
                      float existingAlpha = diffuseColor.a;
                      float finalAlpha = existingAlpha * (1.0 - texColor.a * decalOpacities[i]) + texColor.a * decalOpacities[i];

                        // Check if the final alpha is less than a very small threshold, treat it as fully transparent
                        if (finalAlpha < 0.001) {
                            diffuseColor.a = 0.0;
                        } else {
                            // Blend the colors using the calculated alpha value
                            diffuseColor.rgb = (texColor.rgb * texColor.a * decalOpacities[i] + diffuseColor.rgb * existingAlpha * (1.0 - texColor.a * decalOpacities[i])) / finalAlpha;
                            diffuseColor.a = finalAlpha;
                        }
                    }
                }
            #endif
            `
        );
    };

    // Trigger Rerender of Material
    mesh.material.needsUpdate = true;
}

function flipDecalHorizontal() {
    if (currentDecal) {
        currentDecal.flipX = !currentDecal.flipX;
        renderLayer();
        updateDecalControls();
    }
}

function flipDecalVertical() {
    if (currentDecal) {
        currentDecal.flipY = !currentDecal.flipY;
        renderLayer();
        updateDecalControls();
    }
}

function deleteCurrentDecal() {
    if (!currentDecal || !currentLayer) return;
    
    const index = currentLayer.decals.indexOf(currentDecal);
    if (index > -1) {
        currentLayer.decals.splice(index, 1);
    }
    
    updateDecalList();
    hideDecalControls({ target: document.body });
    currentDecal = null;
    renderLayer();
}

function handleImageUpload(event) {
    const files = event.target.files;
    if (!files.length) return;
    
    // In production, upload to server
    debugLog('Uploading files:', files);
    
    for (const file of files) {
        uploadImageFile(file);
    }
}

function uploadImageFile(file) {
    const formData = new FormData();
    formData.append('image', file);
    formData.append('csrf_token', window.csrfToken);
    
    fetch('/api/images.php', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Refresh image grid
            loadCategoryImages(currentImageCategory);
        } else {
            debugError('Upload failed:', data.error);
        }
    })
    .catch(error => {
        debugError('Upload error:', error);
    });
}

/**
 * Cart Functions
 */
function loadCart() {
    // Load cart from session or local storage
    const cartData = localStorage.getItem('designerCart');
    if (cartData) {
        sizeQuantities = JSON.parse(cartData);
    }
    updateCartBadge();
}

function saveCart() {
    localStorage.setItem('designerCart', JSON.stringify(sizeQuantities));
}

function updateCartBadge() {
    const badge = document.querySelector('.cart-badge');
    const total = Object.values(sizeQuantities).reduce((sum, qty) => sum + qty, 0);
    
    if (badge) {
        badge.textContent = total;
        badge.style.display = total > 0 ? 'block' : 'none';
    }
}

function updateCartModal() {
    const body = document.getElementById('cart-modal-body');
    const total = Object.values(sizeQuantities).reduce((sum, qty) => sum + qty, 0);
    
    if (total === 0) {
        body.innerHTML = '<p class="text-center text-muted">Your cart is empty</p>';
        return;
    }
    
    let html = '<div class="cart-items">';
    Object.entries(sizeQuantities).forEach(([size, quantity]) => {
        if (quantity > 0) {
            const sizeData = window.designerData.product.sizes.find(s => s.name === size);
            if (sizeData) {
                html += `
                    <div class="cart-item mb-3 p-3 border rounded">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <h6 class="mb-1">${window.designerData.product.name}</h6>
                                <small class="text-muted">Size: ${size}</small>
                            </div>
                            <div class="text-end">
                                <div>Qty: ${quantity}</div>
                                <div class="fw-bold">$${(sizeData.price * quantity).toFixed(2)}</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }
    });
    html += '</div>';
    
    body.innerHTML = html;
}

function saveDesign() {
    const designData = {
        product: window.designerData.product.id,
        layers: layers,
        name: designName
    };
    
    // In production, save to server
    debugLog('Saving design:', designData);
    
    // For now, download as JSON
    const blob = new Blob([JSON.stringify(designData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${designName}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

function resetDesign() {
    if (!confirm('Are you sure you want to reset the design? This cannot be undone.')) {
        return;
    }
    
    // Remove all decals from scene
    Object.values(layers).forEach(layer => {
        layer.decals.forEach(decal => {
            if (decal.mesh) {
                scene.remove(decal.mesh);
            }
        });
        layer.decals = [];
        
        // Reset layer color
        layer.color = '#ffffff';
        layer.mesh.material.color.set('#ffffff');
    });
    
    // Update UI
    updateLayerContent();
    updateColorPicker();
    currentDecal = null;
    hideDecalControls({ target: document.body });
}

function proceedToCheckout() {
    // Save design data to session for checkout
    const designData = {
        product: window.designerData.product.id,
        layers: layers,
        sizeQuantities: sizeQuantities
    };
    
    fetch('/api/save-design-session.php', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(designData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = '/checkout';
        } else {
            debugError('Failed to save design for checkout');
        }
    });
}

/**
 * Layer switching for topbar
 */
function switchLayer(layerName) {
    if (layers[layerName]) {
        setCurrentLayer(layerName);
    } else {
        // Map generic layer names to actual mesh names
        const layerMap = {
            'front': Object.keys(layers)[0],
            'back': Object.keys(layers)[1]
        };
        
        if (layerMap[layerName] && layers[layerMap[layerName]]) {
            setCurrentLayer(layerMap[layerName]);
        }
    }
}

// Modal functions for global access
window.openTextModal = function() {
    const modal = new bootstrap.Modal(document.getElementById('textModal'));
    modal.show();
};

window.openImageBankModal = function() {
    const modal = new bootstrap.Modal(document.getElementById('imageBankModal'));
    modal.show();
};

window.openMaterialModal = function() {
    const modal = new bootstrap.Modal(document.getElementById('materialModal'));
    modal.show();
};

window.openSizeModal = function() {
    resetSizeModal();
    const modal = new bootstrap.Modal(document.getElementById('sizeModal'));
    modal.show();
};

window.openCartModal = function() {
    updateCartModal();
    const modal = new bootstrap.Modal(document.getElementById('cartModal'));
    modal.show();
};

// Size modal functions
window.updateQuantity = function(sizeName, delta) {
    const input = document.getElementById(`qty-${sizeName}`);
    const currentValue = parseInt(input.value) || 0;
    const newValue = Math.max(0, Math.min(99, currentValue + delta));
    input.value = newValue;
    updateQuantityInput(sizeName, newValue);
};

window.updateQuantityInput = function(sizeName, value) {
    const numValue = Math.max(0, Math.min(99, parseInt(value) || 0));
    const input = document.getElementById(`qty-${sizeName}`);
    input.value = numValue;
    
    // Update size card appearance
    const sizeCard = document.querySelector(`[data-size="${sizeName}"]`);
    if (numValue > 0) {
        sizeCard.classList.add('has-quantity');
    } else {
        sizeCard.classList.remove('has-quantity');
    }
    
    updateSizeModalTotals();
};

function resetSizeModal() {
    // Reset all quantities to 0
    document.querySelectorAll('.qty-input').forEach(input => {
        input.value = 0;
    });
    
    // Remove has-quantity class from all cards
    document.querySelectorAll('.size-card').forEach(card => {
        card.classList.remove('has-quantity');
    });
    
    updateSizeModalTotals();
}

function updateSizeModalTotals() {
    let totalItems = 0;
    let totalPrice = 0;
    
    document.querySelectorAll('.size-card').forEach(card => {
        const sizeName = card.dataset.size;
        const price = parseFloat(card.dataset.price);
        const input = document.getElementById(`qty-${sizeName}`);
        const quantity = parseInt(input.value) || 0;
        
        totalItems += quantity;
        totalPrice += price * quantity;
    });
    
    document.getElementById('total-items').textContent = `Total: ${totalItems} item${totalItems !== 1 ? 's' : ''}`;
    document.getElementById('total-price').textContent = `$${totalPrice.toFixed(2)}`;
    
    // Enable/disable add to cart button
    const addButton = document.getElementById('add-to-cart-btn');
    addButton.disabled = totalItems === 0;
}

window.addToCart = function() {
    const selections = {};
    let hasItems = false;
    
    // Collect all size selections
    document.querySelectorAll('.size-card').forEach(card => {
        const sizeName = card.dataset.size;
        const price = parseFloat(card.dataset.price);
        const input = document.getElementById(`qty-${sizeName}`);
        const quantity = parseInt(input.value) || 0;
        
        if (quantity > 0) {
            selections[sizeName] = {
                quantity: quantity,
                price: price
            };
            hasItems = true;
        }
    });
    
    if (!hasItems) return;
    
    // Save design data and cart selections
    const designData = {
        product_id: window.designerData.product.id,
        layers: layers,
        selections: selections
    };
    
    // Add to cart via API
    fetch('/api/add-to-cart.php', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(designData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Update local cart tracking
            Object.assign(sizeQuantities, selections);
            saveCart();
            updateCartBadge();
            
            // Close modal and show success
            bootstrap.Modal.getInstance(document.getElementById('sizeModal')).hide();
            
            // Optional: Show success message
            debugLog('Added to cart successfully');
        } else {
            debugError('Failed to add to cart:', data.error);
        }
    })
    .catch(error => {
        debugError('Add to cart error:', error);
    });
};

function openTemplatesModal() {
    // Placeholder for templates functionality
    alert('Templates feature coming soon!');
}

function addFadeDecal() {
    // Placeholder for fade decal functionality
    alert('Fade decal feature coming soon!');
}

function initializeLayerMaterialsDropdown() {
    const trigger = document.getElementById('layer-materials-trigger');
    const menu = document.getElementById('layer-materials-menu');
    
    if (!trigger || !menu) return;
    
    // Populate materials menu
    populateLayerMaterialsMenu();
    
    // Toggle dropdown on trigger click
    trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        trigger.classList.toggle('active');
        menu.classList.toggle('show');
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!trigger.contains(e.target) && !menu.contains(e.target)) {
            trigger.classList.remove('active');
            menu.classList.remove('show');
        }
    });
}

function populateLayerMaterialsMenu() {
    const menu = document.getElementById('layer-materials-menu');
    if (!menu) return;
    
    // Basic material options - you can expand this based on your data
    const materials = [
        { name: 'Standard', thumbnail: '/static/bumpmaps/fabric.png', metalness: 0, roughness: 0.5 },
        { name: 'Metallic', thumbnail: '/static/bumpmaps/metal_thumbnail.jpg', metalness: 1, roughness: 0.2 },
        { name: 'Glossy', thumbnail: '/static/bumpmaps/polyester_thumbnail.jpg', metalness: 0, roughness: 0.1 },
        { name: 'Matte', thumbnail: '/static/bumpmaps/fabric3_thumbnail.jpg', metalness: 0, roughness: 0.9 }
    ];
    
    menu.innerHTML = '';
    
    materials.forEach(material => {
        const option = document.createElement('div');
        option.className = 'layer-material-option';
        option.innerHTML = `
            <div class="material-preview" style="background-image: url('${material.thumbnail}')"></div>
            <span>${material.name}</span>
        `;
        
        option.addEventListener('click', () => {
            selectLayerMaterial(material);
        });
        
        menu.appendChild(option);
    });
}

function selectLayerMaterial(material) {
    if (!currentLayer) return;
    
    // Apply material to current layer
    if (currentLayer.mesh && currentLayer.mesh.material) {
        currentLayer.mesh.material.metalness = material.metalness;
        currentLayer.mesh.material.roughness = material.roughness;
        currentLayer.mesh.material.needsUpdate = true;
    }
    
    // Update active state
    document.querySelectorAll('.layer-material-option').forEach(option => {
        option.classList.remove('active');
    });
    event.target.closest('.layer-material-option').classList.add('active');
    
    // Close dropdown
    const trigger = document.getElementById('layer-materials-trigger');
    const menu = document.getElementById('layer-materials-menu');
    if (trigger && menu) {
        trigger.classList.remove('active');
        menu.classList.remove('show');
    }
    
    debugLog(`Applied ${material.name} material to layer: ${currentLayer.name}`);
}

// Global action functions
window.addTextToCanvas = addTextToCanvas;
window.addSelectedImageToCanvas = addSelectedImageToCanvas;
window.handleImageUpload = handleImageUpload;
window.saveDesign = saveDesign;
window.resetDesign = resetDesign;
window.proceedToCheckout = proceedToCheckout;
window.switchLayer = switchLayer;
window.flipDecalHorizontal = flipDecalHorizontal;
window.flipDecalVertical = flipDecalVertical;
window.deleteCurrentDecal = deleteCurrentDecal;
window.openTemplatesModal = openTemplatesModal;
window.addFadeDecal = addFadeDecal;